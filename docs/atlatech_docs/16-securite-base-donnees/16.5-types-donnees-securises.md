---
title: Types de Données Sécurisés
sidebar_label: "16.5 Types de Données"
sidebar_position: 6
---

# 16.5 Types de Données Sécurisés

## Introduction

Le choix des types de données appropriés est crucial pour la sécurité, la performance et l'intégrité des données.

### Pourquoi les types de données sont importants

**Pour les non-techniciens :** Utiliser le bon type de données, c'est comme choisir le bon contenant. On ne met pas de l'eau dans un panier percé, ni des bijoux dans un sac poubelle.

**Pour les techniciens :** Les types de données définissent les valeurs autorisées, l'espace de stockage, et permettent des validations au niveau base de données.

---

## 16.5.1 État AVANT (Vulnérable)

### Problème : VARCHAR pour tout

**Schéma initial (vulnérable) :**

```sql
CREATE TABLE employes_old (
    employe_id INT,
    nom VARCHAR(255),
    prenom VARCHAR(255),
    email VARCHAR(255),
    telephone VARCHAR(255),
    date_embauche VARCHAR(255),  -- ⚠️ Date en VARCHAR !
    salaire VARCHAR(255),         -- ⚠️ Nombre en VARCHAR !
    actif VARCHAR(255),           -- ⚠️ Booléen en VARCHAR !
    type_contrat VARCHAR(255),    -- ⚠️ Pas de validation
    departement VARCHAR(255)      -- ⚠️ Texte libre
);
```

### Conséquences

**Problème 1 : Données incohérentes**

```sql
INSERT INTO employes_old VALUES 
(1, 'Dupont', 'Jean', 'email', '06123', '2020-01-15', '50000', 'true', 'CDI', 'IT'),
(2, 'Martin', 'Marie', 'invalid', 'abc', '15/01/2020', 'cinquante mille', 'oui', 'cdi', 'Informatique'),
(3, 'Durand', 'Paul', 'test@test', '123456789012345', 'hier', 'gratuit', '1', 'stage', 'IT');

-- Toutes les insertions réussissent !
```

**Analyse des problèmes :**

| Colonne | Valeur invalide | Problème |
|---------|----------------|----------|
| date_embauche | "hier", "15/01/2020" | Format incohérent, impossible à trier |
| salaire | "cinquante mille", "gratuit" | Impossible de calculer des moyennes |
| actif | "true", "oui", "1" | Valeurs multiples pour le même concept |
| type_contrat | "CDI", "cdi", "stage" | Casse différente, typos possibles |
| departement | "IT", "Informatique" | Doublons logiques |

**Problème 2 : Requêtes erronées**

```sql
-- Moyenne des salaires : ERREUR
SELECT AVG(salaire) FROM employes_old;
-- ERROR: Illegal mix of collations

-- Tri par date : INCOHÉRENT
SELECT * FROM employes_old ORDER BY date_embauche;
-- Résultat : "15/01/2020" avant "2020-01-15" (tri alphabétique)
```

---

## 16.5.2 État APRÈS (Sécurisé)

### Types de données appropriés

**Schéma sécurisé :**

```sql
CREATE TABLE employes (
    employe_id INT AUTO_INCREMENT PRIMARY KEY,
    nom VARCHAR(100) NOT NULL,
    prenom VARCHAR(100) NOT NULL,
    email VARCHAR(150) NOT NULL UNIQUE,
    telephone VARCHAR(20),
    date_embauche DATE NOT NULL,                    -- ✓ Type DATE
    salaire DECIMAL(10,2),                          -- ✓ Type DECIMAL
    actif BOOLEAN DEFAULT TRUE,                     -- ✓ Type BOOLEAN
    type_contrat ENUM('CDI', 'CDD', 'Stage', 'Alternance') NOT NULL,  -- ✓ ENUM
    departement_id INT NOT NULL,                    -- ✓ FK vers table departements
    FOREIGN KEY (departement_id) REFERENCES departements(departement_id)
);
```

### Validation automatique

**Test d'insertion invalide :**

```sql
-- Tentative avec date invalide
INSERT INTO employes (nom, prenom, email, date_embauche, type_contrat, departement_id)
VALUES ('Test', 'User', 'test@test.ma', 'hier', 'CDI', 2);

-- ERROR 1292 (22007): Incorrect date value: 'hier' for column 'date_embauche'
```

**Test avec salaire négatif :**

```sql
-- Ajout d'une contrainte CHECK
ALTER TABLE employes ADD CONSTRAINT chk_salaire_positif CHECK (salaire >= 0);

-- Tentative d'insertion
INSERT INTO employes (nom, prenom, email, date_embauche, salaire, type_contrat, departement_id)
VALUES ('Test', 'User', 'test@test.ma', '2026-01-01', -5000, 'CDI', 2);

-- ERROR 4025 (23000): CONSTRAINT `chk_salaire_positif` failed for `atlastech_db`.`employes`
```

---

## 16.5.3 Types de données par catégorie

### Types numériques

**Tableau comparatif :**

| Type | Plage | Taille | Cas d'usage |
|------|-------|--------|-------------|
| **TINYINT** | -128 à 127 | 1 octet | Âge, nombre d'enfants |
| **SMALLINT** | -32768 à 32767 | 2 octets | Quantité stock |
| **INT** | -2M à 2M | 4 octets | ID, compteurs |
| **BIGINT** | -9×10^18 à 9×10^18 | 8 octets | IDs très volumineuses |
| **DECIMAL(10,2)** | Précis | Variable | Prix, salaires (JAMAIS FLOAT !) |

**Exemple : Salaires**

```sql
-- MAUVAIS : FLOAT (approximatif)
salaire FLOAT;
INSERT INTO test VALUES (15000.00);
SELECT salaire FROM test;
-- Résultat : 15000.0009765625 (perte de précision)

-- BON : DECIMAL (exact)
salaire DECIMAL(10,2);
INSERT INTO test VALUES (15000.00);
SELECT salaire FROM test;
-- Résultat : 15000.00 (exact)
```

### Types date et heure

| Type | Format | Plage | Cas d'usage |
|------|--------|-------|-------------|
| **DATE** | YYYY-MM-DD | 1000-01-01 à 9999-12-31 | Date de naissance, embauche |
| **DATETIME** | YYYY-MM-DD HH:MM:SS | 1000 à 9999 | Date de création |
| **TIMESTAMP** | YYYY-MM-DD HH:MM:SS | 1970 à 2038 | Logs, événements |
| **TIME** | HH:MM:SS | -838:59:59 à 838:59:59 | Durée, horaire |

**Exemple : Gestion des congés**

```sql
CREATE TABLE conges (
    conge_id INT AUTO_INCREMENT PRIMARY KEY,
    employe_id INT NOT NULL,
    date_debut DATE NOT NULL,
    date_fin DATE NOT NULL,
    heure_debut TIME,
    heure_fin TIME,
    duree_jours DECIMAL(4,2) GENERATED ALWAYS AS (DATEDIFF(date_fin, date_debut) + 1) STORED,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- Insertion
INSERT INTO conges (employe_id, date_debut, date_fin, heure_debut, heure_fin)
VALUES (2, '2026-03-01', '2026-03-05', '09:00:00', '17:00:00');

-- La colonne duree_jours se calcule automatiquement
SELECT * FROM conges;
```

**Résultat :**

| date_debut | date_fin | duree_jours | created_at |
|------------|----------|-------------|------------|
| 2026-03-01 | 2026-03-05 | 5.00 | 2026-02-09 14:30:15 |

### Types ENUM et SET

**ENUM : Choix unique parmi une liste**

```sql
type_contrat ENUM('CDI', 'CDD', 'Stage', 'Alternance') NOT NULL;
statut_commande ENUM('En attente', 'Confirmée', 'En cours', 'Livrée', 'Annulée') DEFAULT 'En attente';
civilite ENUM('M.', 'Mme', 'Mlle');
```

**Avantages :**
- Stockage optimisé (1-2 octets)
- Validation automatique
- Impossible d'insérer une valeur hors liste

**Test :**

```sql
INSERT INTO employes (nom, prenom, email, type_contrat, date_embauche, departement_id)
VALUES ('Test', 'User', 'test@test.ma', 'Freelance', '2026-01-01', 2);

-- ERROR 1265 (01000): Data truncated for column 'type_contrat' at row 1
```

**SET : Choix multiples**

```sql
CREATE TABLE employes_competences (
    employe_id INT,
    competences SET('PHP', 'Python', 'JavaScript', 'Java', 'C++', 'SQL') NOT NULL
);

-- Insertion de plusieurs valeurs
INSERT INTO employes_competences VALUES 
(1, 'PHP,JavaScript,SQL'),
(2, 'Python,SQL');

-- Recherche
SELECT * FROM employes_competences WHERE FIND_IN_SET('PHP', competences);
```

### Types BOOLEAN

**BOOLEAN = TINYINT(1)**

```sql
actif BOOLEAN DEFAULT TRUE;
must_change_password BOOLEAN DEFAULT FALSE;
is_admin BOOLEAN DEFAULT FALSE;

-- Valeurs autorisées : 0, 1, TRUE, FALSE
INSERT INTO employes (..., actif) VALUES (..., TRUE);
INSERT INTO employes (..., actif) VALUES (..., 1);  -- Équivalent

-- Requête
SELECT * FROM employes WHERE actif = TRUE;
SELECT * FROM employes WHERE actif;  -- Équivalent
```

---

## 16.5.4 Types texte

**Tableau comparatif :**

| Type | Longueur max | Stockage | Cas d'usage |
|------|--------------|----------|-------------|
| **CHAR(n)** | n (fixe) | n octets | Code postal, CIN (longueur fixe) |
| **VARCHAR(n)** | n (variable) | longueur + 1-2 octets | Nom, email, texte court |
| **TEXT** | 65535 | longueur + 2 octets | Description, notes |
| **MEDIUMTEXT** | 16 Mo | longueur + 3 octets | Articles, documents |
| **LONGTEXT** | 4 Go | longueur + 4 octets | Logs, données volumineuses |

**Exemple : CIN (longueur fixe)**

```sql
-- BON : CHAR pour longueur fixe
cin CHAR(8);  -- CIN marocaine = toujours 8 caractères

-- MAUVAIS : VARCHAR gaspille de l'espace
cin VARCHAR(255);  -- Stocke "AB123456" + longueur variable
```

**Exemple : Description produit**

```sql
-- BON : TEXT pour texte long
description TEXT;

-- MAUVAIS : VARCHAR(255) = description tronquée
description VARCHAR(255);
```

---

## 16.5.5 Validation avancée avec CHECK

### Contraintes CHECK

**Email valide :**

```sql
ALTER TABLE clients
ADD CONSTRAINT chk_email_format 
CHECK (email REGEXP '^[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\\.[A-Za-z]{2,}$');

-- Test invalide
INSERT INTO clients (nom, prenom, email)
VALUES ('Test', 'User', 'email_invalide');

-- ERROR 4025 (23000): CONSTRAINT `chk_email_format` failed
```

**Téléphone marocain :**

```sql
ALTER TABLE clients
ADD CONSTRAINT chk_telephone_maroc
CHECK (telephone REGEXP '^(06|07)[0-9]{8}$');

-- Test
INSERT INTO clients (nom, prenom, email, telephone)
VALUES ('Test', 'User', 'test@test.ma', '0612345678');  -- OK

INSERT INTO clients (nom, prenom, email, telephone)
VALUES ('Test2', 'User2', 'test2@test.ma', '0512345678');  -- ERREUR (commence par 05)
```

**Salaire dans une fourchette :**

```sql
ALTER TABLE employes
ADD CONSTRAINT chk_salaire_fourchette
CHECK (salaire BETWEEN 3000 AND 100000);
```

**Dates cohérentes :**

```sql
ALTER TABLE conges
ADD CONSTRAINT chk_dates_logiques
CHECK (date_fin >= date_debut);

ALTER TABLE employes
ADD CONSTRAINT chk_date_embauche_passee
CHECK (date_embauche <= CURDATE());
```

---

## 16.5.6 Types binaires pour chiffrement

### VARBINARY pour données chiffrées

**Stockage de données sensibles :**

```sql
CREATE TABLE employes (
    employe_id INT PRIMARY KEY,
    nom VARCHAR(100),
    telephone_crypte VARBINARY(256),        -- Téléphone chiffré AES-256
    cin_crypte VARBINARY(256),              -- CIN chiffré
    iban_crypte VARBINARY(512)              -- IBAN chiffré
);

-- Insertion avec chiffrement
INSERT INTO employes (employe_id, nom, telephone_crypte)
VALUES (1, 'Dupont', AES_ENCRYPT('0612345678', 'cle_secrete_32_caracteres'));

-- Lecture avec déchiffrement
SELECT 
    employe_id,
    nom,
    CAST(AES_DECRYPT(telephone_crypte, 'cle_secrete_32_caracteres') AS CHAR) AS telephone
FROM employes;
```

**Résultat :**

| employe_id | nom | telephone |
|------------|-----|-----------|
| 1 | Dupont | 0612345678 |

---

## 16.5.7 Colonnes calculées (GENERATED)

### GENERATED ALWAYS AS

**Calcul automatique :**

```sql
CREATE TABLE produits (
    produit_id INT PRIMARY KEY,
    prix_ht DECIMAL(10,2) NOT NULL,
    tva DECIMAL(4,2) DEFAULT 20.00,
    prix_ttc DECIMAL(10,2) GENERATED ALWAYS AS (prix_ht * (1 + tva/100)) STORED
);

-- Insertion
INSERT INTO produits (produit_id, prix_ht) VALUES (1, 1000.00);

-- Lecture
SELECT * FROM produits;
```

**Résultat :**

| produit_id | prix_ht | tva | prix_ttc |
|------------|---------|-----|----------|
| 1 | 1000.00 | 20.00 | 1200.00 |

**La colonne prix_ttc se calcule automatiquement !**

**Autre exemple : Nom complet**

```sql
ALTER TABLE employes
ADD COLUMN nom_complet VARCHAR(200) 
GENERATED ALWAYS AS (CONCAT(prenom, ' ', nom)) STORED;

SELECT nom_complet FROM employes;
```

**Résultat :**

| nom_complet |
|-------------|
| Abdelaziz Haidar |
| Oumayma Lafridi |
| Ibtissam Elghbali |

---

## 16.5.8 Migration des types de données

### Script de migration

**Convertir VARCHAR → types appropriés :**

```sql
-- Backup avant modification
CREATE TABLE employes_backup AS SELECT * FROM employes;

-- Conversion des types
ALTER TABLE employes 
MODIFY COLUMN date_embauche DATE NOT NULL,
MODIFY COLUMN salaire DECIMAL(10,2),
MODIFY COLUMN actif BOOLEAN DEFAULT TRUE,
MODIFY COLUMN type_contrat ENUM('CDI', 'CDD', 'Stage', 'Alternance') NOT NULL;

-- Vérification
DESCRIBE employes;
```

**Résultat :**

| Field | Type | Null | Key |
|-------|------|------|-----|
| date_embauche | date | NO | |
| salaire | decimal(10,2) | YES | |
| actif | tinyint(1) | YES | |
| type_contrat | enum('CDI','CDD','Stage','Alternance') | NO | |

---

## 16.5.9 Performance et espace disque

### Comparaison stockage

**Exemple : Table de 100000 employés**

| Colonne | Type AVANT (VARCHAR) | Type APRÈS | Espace gagné |
|---------|---------------------|------------|--------------|
| date_embauche | VARCHAR(255) = 255 octets | DATE = 3 octets | **98.8%** |
| salaire | VARCHAR(255) = 255 octets | DECIMAL(10,2) = 5 octets | **98%** |
| actif | VARCHAR(255) = 255 octets | BOOLEAN = 1 octet | **99.6%** |
| type_contrat | VARCHAR(255) = 255 octets | ENUM = 1 octet | **99.6%** |

**Total pour 100000 lignes :**
- AVANT : 100000 × 1020 octets = 97 MB
- APRÈS : 100000 × 10 octets = 0.95 MB

**Économie : 99% d'espace disque !**

---

## Conclusion

Les types de données sécurisés implémentés dans AtlasTech Solutions :

**Avantages :**
- Validation automatique au niveau base de données
- Économie de 99% d'espace disque
- Performance améliorée (tri, calculs, recherches)
- Impossibilité d'insérer des données incohérentes

**Types utilisés :**
- ENUM pour les choix limités (5 colonnes)
- DATE/DATETIME pour les dates (8 colonnes)
- DECIMAL pour les montants (4 colonnes)
- BOOLEAN pour les drapeaux (3 colonnes)
- VARBINARY pour les données chiffrées (3 colonnes)

**Prochaine section :** 16.6 Procédures Stockées Sécurisées