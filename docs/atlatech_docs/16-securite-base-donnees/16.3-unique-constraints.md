---
title: UNIQUE Constraints
sidebar_label: "16.3 UNIQUE Constraints"
sidebar_position: 4
---

# 16.3 UNIQUE Constraints

## Introduction

Les contraintes UNIQUE garantissent qu'une valeur ne peut apparaître qu'une seule fois dans une colonne ou une combinaison de colonnes.

### Pourquoi utiliser UNIQUE ?

**Pour les non-techniciens :** Imaginez un registre d'étudiants. Deux étudiants ne peuvent pas avoir le même numéro d'étudiant, sinon impossible de les distinguer. UNIQUE garantit cette unicité.

**Pour les techniciens :** UNIQUE est une contrainte d'intégrité qui empêche les doublons, essentielle pour les identifiants métier (email, CIN, téléphone).

---

## 16.3.1 État AVANT (Vulnérable)

### Problème : Doublons possibles

**Vérification de l'absence de contraintes :**

```sql
SHOW INDEX FROM employes WHERE Non_unique = 0;
```

**Résultat (AVANT) :**

| Key_name | Column_name | Non_unique |
|----------|-------------|------------|
| PRIMARY | employe_id | 0 |

**Seule la clé primaire est unique !**

### Démonstration du problème

**Insertion de doublons email :**

```sql
INSERT INTO employes (utilisateur, nom, prenom, email, departement_id, type_contrat, date_embauche)
VALUES ('user1', 'Dupont', 'Jean', 'jean.dupont@company.ma', 2, 'CDI', '2026-01-01');

-- Deuxième insertion avec le MÊME email
INSERT INTO employes (utilisateur, nom, prenom, email, departement_id, type_contrat, date_embauche)
VALUES ('user2', 'Martin', 'Pierre', 'jean.dupont@company.ma', 3, 'CDD', '2026-01-15');

-- Query OK, 2 rows affected
-- Les deux insertions réussissent !
```

**Conséquence :**

```sql
SELECT * FROM employes WHERE email = 'jean.dupont@company.ma';
```

**Résultat :**

| employe_id | utilisateur | nom | prenom | email |
|------------|-------------|-----|--------|-------|
| 26 | user1 | Dupont | Jean | jean.dupont@company.ma |
| 27 | user2 | Martin | Pierre | jean.dupont@company.ma |

**Problèmes :**
- Impossible de savoir quel est le "vrai" compte
- Système d'authentification cassé (deux comptes avec le même email)
- Violation RGPD (données personnelles dupliquées)

---

## 16.3.2 État APRÈS (Sécurisé)

### Ajout de contraintes UNIQUE

#### Table employes

```sql
-- Email unique
ALTER TABLE employes
ADD UNIQUE INDEX uk_employes_email (email);

-- Nom d'utilisateur unique
ALTER TABLE employes
ADD UNIQUE INDEX uk_employes_utilisateur (utilisateur);

-- CIN unique
ALTER TABLE employes
ADD UNIQUE INDEX uk_employes_cin (cin);
```

**Test de la contrainte :**

```sql
INSERT INTO employes (utilisateur, nom, prenom, email, departement_id, type_contrat, date_embauche)
VALUES ('oumayma.l', 'Lafridi', 'Oumayma', 'nouvelle.email@company.ma', 2, 'CDI', '2026-02-01');

-- Résultat :
-- ERROR 1062 (23000): Duplicate entry 'oumayma.l' for key 'uk_employes_utilisateur'
```

L'insertion est **bloquée** car 'oumayma.l' existe déjà.

#### Table clients

```sql
-- Email client unique
ALTER TABLE clients
ADD UNIQUE INDEX uk_clients_email (email);

-- Téléphone unique (optionnel)
ALTER TABLE clients
ADD UNIQUE INDEX uk_clients_telephone (telephone);
```

**Cas particulier : UNIQUE avec NULL**

```sql
-- Le téléphone peut être NULL
INSERT INTO clients (nom, prenom, email, telephone)
VALUES ('Test', 'User', 'test1@example.ma', NULL);

INSERT INTO clients (nom, prenom, email, telephone)
VALUES ('Test2', 'User2', 'test2@example.ma', NULL);

-- Les deux insertions réussissent car NULL != NULL en SQL
-- Plusieurs NULL sont autorisés dans une colonne UNIQUE
```

#### Table departements

```sql
-- Nom de département unique
ALTER TABLE departements
ADD UNIQUE INDEX uk_departements_nom (nom_departement);
```

**Test :**

```sql
INSERT INTO departements (nom_departement, description)
VALUES ('Informatique', 'Nouvelle description');

-- ERROR 1062 (23000): Duplicate entry 'Informatique' for key 'uk_departements_nom'
```

---

## 16.3.3 UNIQUE Composites (Multi-colonnes)

### Cas d'usage : Éviter les doublons de congés

**Problème :** Un employé ne peut pas avoir deux congés avec les mêmes dates.

```sql
ALTER TABLE conges
ADD UNIQUE INDEX uk_conges_employe_dates (employe_id, date_debut, date_fin);
```

**Test :**

```sql
-- Première insertion
INSERT INTO conges (employe_id, type_conge, date_debut, date_fin)
VALUES (2, 'Congé payé', '2026-03-01', '2026-03-07');
-- Query OK

-- Tentative de doublon
INSERT INTO conges (employe_id, type_conge, date_debut, date_fin)
VALUES (2, 'Congé maladie', '2026-03-01', '2026-03-07');

-- ERROR 1062 (23000): Duplicate entry '2-2026-03-01-2026-03-07' 
-- for key 'uk_conges_employe_dates'
```

**Mais ceci est autorisé :**

```sql
INSERT INTO conges (employe_id, type_conge, date_debut, date_fin)
VALUES (3, 'Congé payé', '2026-03-01', '2026-03-07');
-- Query OK (autre employé, mêmes dates = OK)
```

### Cas d'usage : Ligne de commande unique

**Problème :** Éviter d'ajouter deux fois le même produit dans une commande.

```sql
ALTER TABLE details_commande
ADD UNIQUE INDEX uk_details_commande_produit (commande_id, produit_id);
```

**Test :**

```sql
-- Première ligne de commande
INSERT INTO details_commande (commande_id, produit_id, quantite, prix_unitaire)
VALUES (1, 5, 2, 500.00);
-- Query OK

-- Tentative de doublon
INSERT INTO details_commande (commande_id, produit_id, quantite, prix_unitaire)
VALUES (1, 5, 3, 500.00);

-- ERROR 1062 (23000): Duplicate entry '1-5' 
-- for key 'uk_details_commande_produit'
```

**Solution :** Mettre à jour la quantité au lieu d'insérer une nouvelle ligne.

```sql
UPDATE details_commande 
SET quantite = quantite + 3
WHERE commande_id = 1 AND produit_id = 5;
```

---

## 16.3.4 Gestion des doublons existants

### Détecter les doublons avant d'ajouter UNIQUE

**Script de détection :**

```sql
-- Trouver les emails en double
SELECT email, COUNT(*) as nombre_doublons
FROM employes
GROUP BY email
HAVING COUNT(*) > 1;
```

**Résultat (si doublons) :**

| email | nombre_doublons |
|-------|-----------------|
| jean.dupont@company.ma | 2 |
| test@company.ma | 3 |

### Nettoyer les doublons

**Stratégie 1 : Garder le plus ancien**

```sql
-- Créer une table temporaire avec les IDs à garder
CREATE TEMPORARY TABLE employes_a_garder AS
SELECT MIN(employe_id) as employe_id
FROM employes
GROUP BY email;

-- Supprimer les doublons
DELETE FROM employes
WHERE employe_id NOT IN (SELECT employe_id FROM employes_a_garder);

-- Vérification
SELECT email, COUNT(*) FROM employes GROUP BY email HAVING COUNT(*) > 1;
-- Empty set (0.00 sec)
```

**Stratégie 2 : Fusionner les données**

```sql
-- Identifier les doublons
SELECT employe_id, email FROM employes WHERE email = 'doublon@company.ma';

-- Résultat :
-- employe_id 26, email: doublon@company.ma
-- employe_id 27, email: doublon@company.ma

-- Transférer les données du 27 vers le 26
UPDATE salaires SET employe_id = 26 WHERE employe_id = 27;
UPDATE conges SET employe_id = 26 WHERE employe_id = 27;

-- Supprimer le doublon
DELETE FROM employes WHERE employe_id = 27;
```

### Ajouter UNIQUE après nettoyage

```sql
-- Maintenant l'ajout de la contrainte réussira
ALTER TABLE employes
ADD UNIQUE INDEX uk_employes_email (email);

-- Query OK, 0 rows affected
```

---

## 16.3.5 Différence entre UNIQUE et PRIMARY KEY

### Tableau comparatif

| Caractéristique | PRIMARY KEY | UNIQUE |
|-----------------|-------------|--------|
| Autorise NULL | Non | Oui (plusieurs NULL possibles) |
| Nombre par table | 1 seule | Plusieurs contraintes possibles |
| Crée un INDEX | Oui (CLUSTERED) | Oui (NON-CLUSTERED) |
| Identifie de manière unique | Oui | Oui |
| Utilisé pour Foreign Keys | Oui (souvent) | Possible mais rare |

### Exemple pratique

```sql
CREATE TABLE test_unique (
    id INT AUTO_INCREMENT PRIMARY KEY,  -- PRIMARY KEY
    email VARCHAR(100) UNIQUE,          -- UNIQUE (NULL autorisé)
    username VARCHAR(50) UNIQUE         -- UNIQUE (NULL autorisé)
);

-- Test PRIMARY KEY
INSERT INTO test_unique (id, email, username) VALUES (NULL, 'a@a.com', 'user1');
-- Query OK (id auto-incrémenté)

-- Test UNIQUE avec NULL
INSERT INTO test_unique (email, username) VALUES (NULL, 'user2');
INSERT INTO test_unique (email, username) VALUES (NULL, 'user3');
-- Les deux réussissent (plusieurs NULL autorisés)

-- Test doublon UNIQUE
INSERT INTO test_unique (email, username) VALUES ('a@a.com', 'user4');
-- ERROR 1062 (23000): Duplicate entry 'a@a.com' for key 'email'
```

---

## 16.3.6 Vérification des contraintes UNIQUE

### Lister toutes les contraintes UNIQUE

```sql
SELECT 
    TABLE_NAME,
    INDEX_NAME,
    GROUP_CONCAT(COLUMN_NAME ORDER BY SEQ_IN_INDEX) AS colonnes
FROM INFORMATION_SCHEMA.STATISTICS
WHERE TABLE_SCHEMA = 'atlastech_db'
  AND NON_UNIQUE = 0
  AND INDEX_NAME != 'PRIMARY'
GROUP BY TABLE_NAME, INDEX_NAME;
```

**Résultat attendu :**

| TABLE_NAME | INDEX_NAME | colonnes |
|------------|------------|----------|
| employes | uk_employes_email | email |
| employes | uk_employes_utilisateur | utilisateur |
| employes | uk_employes_cin | cin |
| clients | uk_clients_email | email |
| clients | uk_clients_telephone | telephone |
| departements | uk_departements_nom | nom_departement |
| conges | uk_conges_employe_dates | employe_id,date_debut,date_fin |
| details_commande | uk_details_commande_produit | commande_id,produit_id |

### Tester toutes les contraintes

**Script de test automatique :**

```bash
#!/bin/bash
# test_unique_constraints.sh

echo "Test des contraintes UNIQUE"

# Test 1 : Email employé
mysql -u root -p atlastech_db -e "
INSERT INTO employes (utilisateur, nom, prenom, email, departement_id, type_contrat, date_embauche)
VALUES ('test_unique', 'Test', 'Unique', 'o.lafridi@company.ma', 2, 'CDD', '2026-02-01');
"

if [ $? -ne 0 ]; then
    echo "✓ Test 1 PASSED : Email employé unique"
else
    echo "✗ Test 1 FAILED : Email employé non unique"
fi

# Test 2 : Email client
mysql -u root -p atlastech_db -e "
INSERT INTO clients (nom, prenom, email)
VALUES ('Test', 'Client', 'k.benjelloun@example.ma');
"

if [ $? -ne 0 ]; then
    echo "✓ Test 2 PASSED : Email client unique"
else
    echo "✗ Test 2 FAILED : Email client non unique"
fi

# Test 3 : Nom département
mysql -u root -p atlastech_db -e "
INSERT INTO departements (nom_departement)
VALUES ('Informatique');
"

if [ $? -ne 0 ]; then
    echo "✓ Test 3 PASSED : Nom département unique"
else
    echo "✗ Test 3 FAILED : Nom département non unique"
fi

echo "Tests terminés"
```

---

## 16.3.7 Performance des contraintes UNIQUE

### Impact sur INSERT

**Benchmark :**

```sql
-- Sans contrainte UNIQUE
CREATE TABLE test_no_unique (
    id INT AUTO_INCREMENT PRIMARY KEY,
    email VARCHAR(100)
) ENGINE=InnoDB;

-- Insertion de 100000 enregistrements
-- Temps : 5.2 secondes

-- Avec contrainte UNIQUE
CREATE TABLE test_with_unique (
    id INT AUTO_INCREMENT PRIMARY KEY,
    email VARCHAR(100) UNIQUE
) ENGINE=InnoDB;

-- Même insertion
-- Temps : 5.8 secondes

-- Surcharge : 11.5% (très acceptable)
```

### Avantage : Accélération des recherches

```sql
-- Recherche sur colonne UNIQUE (avec INDEX automatique)
EXPLAIN SELECT * FROM employes WHERE email = 'o.lafridi@company.ma';
```

**Résultat :**

| type | possible_keys | key | rows |
|------|---------------|-----|------|
| const | uk_employes_email | uk_employes_email | 1 |

**Type = const** : Le plus rapide possible (lookup direct via INDEX).

---

## 16.3.8 Bonnes pratiques

### Quand utiliser UNIQUE ?

| Colonne | UNIQUE ? | Justification |
|---------|----------|---------------|
| Email | Oui | Identifiant de connexion |
| Téléphone | Oui | Contact unique |
| CIN/Passeport | Oui | Document d'identité |
| Numéro de commande | Oui | Référence métier |
| Nom | Non | Homonymes possibles |
| Adresse | Non | Plusieurs personnes à la même adresse |

### Erreurs courantes à éviter

**Erreur 1 : UNIQUE sur colonnes fréquemment modifiées**

```sql
-- MAUVAIS : Email peut changer fréquemment
ALTER TABLE employes ADD UNIQUE (email);

-- Problème : Chaque changement d'email nécessite de vérifier l'unicité dans toute la table
```

**Solution :** Utiliser un identifiant stable (username, matricule).

**Erreur 2 : Oublier que NULL est autorisé**

```sql
-- Création avec UNIQUE sur téléphone
CREATE TABLE contacts (
    id INT PRIMARY KEY,
    telephone VARCHAR(20) UNIQUE
);

-- Ces deux insertions réussissent !
INSERT INTO contacts VALUES (1, NULL);
INSERT INTO contacts VALUES (2, NULL);

-- Résultat : Deux enregistrements avec telephone = NULL
```

**Solution :** Ajouter NOT NULL si nécessaire.

```sql
ALTER TABLE contacts MODIFY telephone VARCHAR(20) UNIQUE NOT NULL;
```

---

## Conclusion

Les contraintes UNIQUE dans AtlasTech Solutions garantissent :

**Avantages :**
- Prévention des doublons (email, CIN, username)
- Conformité métier (un seul compte par email)
- Performance améliorée (INDEX automatiques)
- Intégrité des données à 100%

**Contraintes appliquées :**
- 8 contraintes UNIQUE (3 sur employes, 2 sur clients, 1 sur departements, 2 composites)
- Surcharge performance négligeable (< 12%)

**Prochaine section :** 16.4 INDEX pour Performance