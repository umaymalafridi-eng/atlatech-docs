---
title: Audit Database
sidebar_label: "16.9 Audit"
sidebar_position: 10
---

# 16.9 Audit Database

## Introduction

L'audit de base de données permet de tracer toutes les opérations effectuées, essentiel pour la sécurité, la conformité et la détection d'incidents.

### Pourquoi auditer la base de données ?

**Pour les non-techniciens :** L'audit est comme un système de vidéosurveillance. Il enregistre qui a fait quoi, quand, et permet de revoir l'historique en cas de problème.

**Pour les techniciens :** L'audit log capture les requêtes SQL, connexions, et modifications de données pour assurer la traçabilité et la conformité réglementaire.

---

## 16.9.1 État AVANT (Sans audit)

### Problème : Aucune traçabilité

**Vérification des logs :**

```sql
SHOW VARIABLES LIKE 'general_log%';
```

**Résultat :**

| Variable_name | Value |
|---------------|-------|
| general_log | OFF |
| general_log_file | /var/log/mysql/mysql.log |

**Impact :**
- Impossible de savoir qui a modifié quoi
- Aucune preuve en cas d'incident
- Non-conformité RGPD (obligation de traçabilité)

---

## 16.9.2 Activation du General Log

### Configuration MariaDB

```sql
-- Activer le general log
SET GLOBAL general_log = 'ON';
SET GLOBAL general_log_file = '/var/log/mysql/general.log';

-- Vérification
SHOW VARIABLES LIKE 'general_log%';
```

**Résultat :**

| Variable_name | Value |
|---------------|-------|
| general_log | ON |
| general_log_file | /var/log/mysql/general.log |

### Consultation du log

```bash
tail -f /var/log/mysql/general.log
```

**Exemple de sortie :**

```
2026-02-09T14:30:15.123456Z    42 Connect   hr_app_user@localhost on atlastech_db
2026-02-09T14:30:15.234567Z    42 Query     SELECT * FROM employes WHERE nom = 'Haidar'
2026-02-09T14:30:18.345678Z    42 Query     UPDATE employes SET email = 'new@company.ma' WHERE employe_id = 1
2026-02-09T14:30:20.456789Z    42 Quit
```

**Informations capturées :**
- Timestamp précis
- ID de connexion
- Utilisateur et host
- Requête SQL exacte

---

## 16.9.3 Audit Plugin (MariaDB Server Audit)

### Installation du plugin

```sql
INSTALL SONAME 'server_audit';

-- Vérifier l'installation
SHOW PLUGINS;
```

**Résultat :**

| Name | Status | Type | Library |
|------|--------|------|---------|
| SERVER_AUDIT | ACTIVE | AUDIT | server_audit.so |

### Configuration du plugin

```sql
-- Activer l'audit
SET GLOBAL server_audit_logging = ON;

-- Fichier de log
SET GLOBAL server_audit_file_path = '/var/log/mysql/audit.log';

-- Événements à logger
SET GLOBAL server_audit_events = 'CONNECT,QUERY,TABLE';

-- Utilisateurs à auditer (tous)
SET GLOBAL server_audit_incl_users = '';

-- Exclure les utilisateurs système
SET GLOBAL server_audit_excl_users = 'mysql.sys,mysql.session';

-- Rotation des logs (100 MB)
SET GLOBAL server_audit_file_rotate_size = 104857600;
SET GLOBAL server_audit_file_rotations = 9;
```

### Rendre la configuration persistante

**Fichier : `/etc/mysql/mariadb.conf.d/50-server.cnf`**

```ini
[mysqld]
# Server Audit Plugin
plugin-load-add = server_audit
server_audit_logging = ON
server_audit_file_path = /var/log/mysql/audit.log
server_audit_events = CONNECT,QUERY,TABLE
server_audit_incl_users = ''
server_audit_excl_users = mysql.sys,mysql.session
server_audit_file_rotate_size = 104857600
server_audit_file_rotations = 9
```

**Redémarrer MariaDB :**

```bash
systemctl restart mariadb
```

---

## 16.9.4 Analyse des logs d'audit

### Format du log d'audit

**Fichier : `/var/log/mysql/audit.log`**

```
20260209 14:35:22,atlastech-mainserver,hr_app_user,localhost,47,0,CONNECT,atlastech_db,,0
20260209 14:35:25,atlastech-mainserver,hr_app_user,localhost,47,123,QUERY,atlastech_db,'SELECT * FROM employes WHERE departement_id = 2',0
20260209 14:35:30,atlastech-mainserver,hr_app_user,localhost,47,124,QUERY,atlastech_db,'UPDATE employes SET email = \'new@mail.ma\' WHERE employe_id = 5',0
20260209 14:35:35,atlastech-mainserver,hr_app_user,localhost,47,0,DISCONNECT,atlastech_db,,0
```

**Structure :**

| Champ | Description | Exemple |
|-------|-------------|---------|
| Timestamp | Date et heure | 20260209 14:35:22 |
| Serveur | Nom du serveur | atlastech-mainserver |
| Utilisateur | Compte MySQL | hr_app_user |
| Host | IP/hostname | localhost |
| Connection ID | ID de session | 47 |
| Query ID | ID de requête | 123 |
| Opération | Type d'événement | QUERY, CONNECT |
| Base | Base de données | atlastech_db |
| Requête | SQL exécuté | SELECT * FROM... |
| Code retour | 0 = succès | 0 |

### Recherche dans les logs

**Qui a modifié l'employé ID 5 ?**

```bash
grep "employe_id = 5" /var/log/mysql/audit.log | grep UPDATE
```

**Résultat :**

```
20260209 14:35:30,atlastech-mainserver,hr_app_user,localhost,47,124,QUERY,atlastech_db,'UPDATE employes SET email = \'new@mail.ma\' WHERE employe_id = 5',0
```

**Toutes les connexions de web_app_user :**

```bash
grep "web_app_user" /var/log/mysql/audit.log | grep CONNECT
```

**Toutes les suppressions :**

```bash
grep "DELETE FROM" /var/log/mysql/audit.log
```

---

## 16.9.5 Table d'audit personnalisée

### Création d'une table de logs

```sql
CREATE TABLE logs_audit (
    log_id BIGINT AUTO_INCREMENT PRIMARY KEY,
    timestamp DATETIME DEFAULT CURRENT_TIMESTAMP,
    user VARCHAR(100),
    host VARCHAR(100),
    action ENUM('INSERT', 'UPDATE', 'DELETE', 'SELECT', 'CREATE', 'DROP', 'ALTER') NOT NULL,
    table_name VARCHAR(100),
    record_id INT,
    old_values TEXT,
    new_values TEXT,
    details TEXT,
    
    INDEX idx_timestamp (timestamp),
    INDEX idx_user (user),
    INDEX idx_action (action),
    INDEX idx_table (table_name)
) ENGINE=InnoDB;
```

### Triggers d'audit automatique

**Trigger sur employes (INSERT) :**

```sql
DELIMITER $$
CREATE TRIGGER trg_audit_employes_insert
AFTER INSERT ON employes
FOR EACH ROW
BEGIN
    INSERT INTO logs_audit (user, host, action, table_name, record_id, new_values)
    VALUES (
        USER(),
        SUBSTRING_INDEX(USER(), '@', -1),
        'INSERT',
        'employes',
        NEW.employe_id,
        CONCAT('nom: ', NEW.nom, ', prenom: ', NEW.prenom, ', email: ', NEW.email)
    );
END$$
DELIMITER ;
```

**Trigger sur employes (UPDATE) :**

```sql
DELIMITER $$
CREATE TRIGGER trg_audit_employes_update
AFTER UPDATE ON employes
FOR EACH ROW
BEGIN
    INSERT INTO logs_audit (user, host, action, table_name, record_id, old_values, new_values)
    VALUES (
        USER(),
        SUBSTRING_INDEX(USER(), '@', -1),
        'UPDATE',
        'employes',
        NEW.employe_id,
        CONCAT('email: ', OLD.email, ', poste: ', OLD.poste),
        CONCAT('email: ', NEW.email, ', poste: ', NEW.poste)
    );
END$$
DELIMITER ;
```

**Trigger sur employes (DELETE) :**

```sql
DELIMITER $$
CREATE TRIGGER trg_audit_employes_delete
BEFORE DELETE ON employes
FOR EACH ROW
BEGIN
    INSERT INTO logs_audit (user, host, action, table_name, record_id, old_values)
    VALUES (
        USER(),
        SUBSTRING_INDEX(USER(), '@', -1),
        'DELETE',
        'employes',
        OLD.employe_id,
        CONCAT('nom: ', OLD.nom, ' ', OLD.prenom, ', email: ', OLD.email)
    );
END$$
DELIMITER ;
```

### Test des triggers

**Insertion :**

```sql
INSERT INTO employes (utilisateur, nom, prenom, email, departement_id, type_contrat, date_embauche)
VALUES ('test.audit', 'Test', 'Audit', 'test.audit@company.ma', 2, 'CDD', '2026-02-01');

-- Vérifier le log
SELECT * FROM logs_audit ORDER BY log_id DESC LIMIT 1;
```

**Résultat :**

| log_id | timestamp | user | action | table_name | record_id | new_values |
|--------|-----------|------|--------|------------|-----------|------------|
| 1 | 2026-02-09 15:00:00 | root@localhost | INSERT | employes | 26 | nom: Test, prenom: Audit, email: test.audit@company.ma |

**Mise à jour :**

```sql
UPDATE employes 
SET email = 'nouveau.email@company.ma', poste = 'Testeur'
WHERE employe_id = 26;

-- Vérifier le log
SELECT * FROM logs_audit ORDER BY log_id DESC LIMIT 1;
```

**Résultat :**

| log_id | timestamp | user | action | old_values | new_values |
|--------|-----------|------|--------|------------|------------|
| 2 | 2026-02-09 15:02:00 | root@localhost | UPDATE | email: test.audit@company.ma, poste: NULL | email: nouveau.email@company.ma, poste: Testeur |

---

## 16.9.6 Audit des connexions

### Table logs_connexion

```sql
CREATE TABLE logs_connexion (
    id INT AUTO_INCREMENT PRIMARY KEY,
    utilisateur VARCHAR(50) NOT NULL,
    date DATETIME DEFAULT CURRENT_TIMESTAMP,
    adresse_ip VARCHAR(45),
    statut ENUM('SUCCES', 'ECHEC', 'LOCKED') NOT NULL,
    navigateur TEXT,
    date_heure TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    
    INDEX idx_utilisateur (utilisateur),
    INDEX idx_statut (statut),
    INDEX idx_date (date_heure)
) ENGINE=InnoDB;
```

### Intégration dans login.php

```php
// Après vérification du mot de passe
if (password_verify($password, $user['mot_de_passe'])) {
    // Log de connexion réussie
    $log_sql = "INSERT INTO logs_connexion (utilisateur, statut, adresse_ip, navigateur) 
                VALUES (?, 'SUCCES', ?, ?)";
    $log_stmt = $conn->prepare($log_sql);
    $ip_address = $_SERVER['REMOTE_ADDR'];
    $user_agent = $_SERVER['HTTP_USER_AGENT'];
    $log_stmt->bind_param("sss", $username, $ip_address, $user_agent);
    $log_stmt->execute();
} else {
    // Log de connexion échouée
    $log_sql = "INSERT INTO logs_connexion (utilisateur, statut, adresse_ip) 
                VALUES (?, 'ECHEC', ?)";
    $log_stmt = $conn->prepare($log_sql);
    $ip_address = $_SERVER['REMOTE_ADDR'];
    $log_stmt->bind_param("ss", $username, $ip_address);
    $log_stmt->execute();
}
```

### Détection des tentatives de brute force

```sql
-- Utilisateurs avec plus de 5 échecs dans les 15 dernières minutes
SELECT 
    utilisateur,
    COUNT(*) AS tentatives_echouees,
    MAX(date_heure) AS derniere_tentative
FROM logs_connexion
WHERE statut = 'ECHEC'
  AND date_heure > DATE_SUB(NOW(), INTERVAL 15 MINUTE)
GROUP BY utilisateur
HAVING COUNT(*) >= 5;
```

**Résultat (si attaque) :**

| utilisateur | tentatives_echouees | derniere_tentative |
|-------------|---------------------|-------------------|
| admin | 12 | 2026-02-09 15:30:45 |

**Action automatique : Verrouillage du compte**

```sql
-- Procédure de verrouillage automatique
DELIMITER $$
CREATE PROCEDURE verifier_brute_force(IN p_utilisateur VARCHAR(50))
BEGIN
    DECLARE v_tentatives INT;
    
    -- Compter les échecs des 15 dernières minutes
    SELECT COUNT(*) INTO v_tentatives
    FROM logs_connexion
    WHERE utilisateur = p_utilisateur
      AND statut = 'ECHEC'
      AND date_heure > DATE_SUB(NOW(), INTERVAL 15 MINUTE);
    
    -- Verrouiller si > 5 tentatives
    IF v_tentatives >= 5 THEN
        UPDATE employes
        SET actif = FALSE
        WHERE utilisateur = p_utilisateur;
        
        INSERT INTO logs_connexion (utilisateur, statut, adresse_ip)
        VALUES (p_utilisateur, 'LOCKED', 'AUTO');
    END IF;
END$$
DELIMITER ;
```

---

## 16.9.7 Rapports d'audit

### Rapport quotidien d'activité

```sql
SELECT 
    DATE(timestamp) AS date,
    action,
    table_name,
    COUNT(*) AS nb_operations
FROM logs_audit
WHERE timestamp >= CURDATE()
GROUP BY DATE(timestamp), action, table_name
ORDER BY date DESC, nb_operations DESC;
```

**Résultat :**

| date | action | table_name | nb_operations |
|------|--------|------------|---------------|
| 2026-02-09 | SELECT | employes | 1250 |
| 2026-02-09 | UPDATE | employes | 15 |
| 2026-02-09 | INSERT | conges | 3 |
| 2026-02-09 | DELETE | clients | 1 |

### Rapport de conformité RGPD

**Toutes les suppressions de données personnelles :**

```sql
SELECT 
    log_id,
    timestamp,
    user,
    table_name,
    record_id,
    old_values
FROM logs_audit
WHERE action = 'DELETE'
  AND table_name IN ('employes', 'clients')
ORDER BY timestamp DESC;
```

### Top 10 utilisateurs actifs

```sql
SELECT 
    user,
    COUNT(*) AS nb_operations,
    MIN(timestamp) AS premiere_operation,
    MAX(timestamp) AS derniere_operation
FROM logs_audit
GROUP BY user
ORDER BY nb_operations DESC
LIMIT 10;
```

---

## 16.9.8 Rétention et archivage des logs

### Politique de rétention

| Type de log | Rétention | Raison |
|-------------|-----------|--------|
| **logs_audit** | 1 an | Conformité ISO 27001 |
| **logs_connexion** | 6 mois | Détection d'incidents |
| **audit.log (fichier)** | 90 jours | Espace disque |

### Archivage automatique

**Script : `archive_logs.sh`**

```bash
#!/bin/bash
# Archivage des logs de plus de 90 jours

LOG_DIR="/var/log/mysql"
ARCHIVE_DIR="/backups/mysql_logs"
DATE=$(date +%Y%m%d)

# Créer le répertoire d'archive
mkdir -p $ARCHIVE_DIR

# Archiver les fichiers audit.log.*
find $LOG_DIR -name "audit.log.*" -mtime +90 -exec gzip {} \;
find $LOG_DIR -name "audit.log.*.gz" -mtime +90 -exec mv {} $ARCHIVE_DIR/ \;

# Archiver la table logs_audit
mysql -u root -p atlastech_db -e "
CREATE TABLE IF NOT EXISTS logs_audit_archive_$DATE 
AS SELECT * FROM logs_audit 
WHERE timestamp < DATE_SUB(NOW(), INTERVAL 1 YEAR);

DELETE FROM logs_audit 
WHERE timestamp < DATE_SUB(NOW(), INTERVAL 1 YEAR);
"

echo "Archivage terminé : $(date)"
```

**Cron (exécution mensuelle) :**

```bash
0 2 1 * * /usr/local/bin/archive_logs.sh >> /var/log/archive_logs.log 2>&1
```

---

## 16.9.9 Alertes en temps réel

### Script de surveillance

**Fichier : `monitor_audit.sh`**

```bash
#!/bin/bash
# Surveillance des événements critiques dans les logs

ALERT_EMAIL="security@atlastech.ma"
LOG_FILE="/var/log/mysql/audit.log"

# Surveiller les DROP TABLE
if tail -n 1000 $LOG_FILE | grep -q "DROP TABLE"; then
    echo "ALERTE: Tentative de DROP TABLE détectée" | \
    mail -s "ALERTE SÉCURITÉ MySQL" $ALERT_EMAIL
fi

# Surveiller les connexions root depuis Internet
if tail -n 1000 $LOG_FILE | grep "CONNECT" | grep "root" | grep -v "localhost" | grep -q "CONNECT"; then
    echo "ALERTE: Connexion root depuis IP externe" | \
    mail -s "ALERTE SÉCURITÉ MySQL" $ALERT_EMAIL
fi

# Surveiller les suppressions massives
DELETE_COUNT=$(tail -n 1000 $LOG_FILE | grep -c "DELETE FROM")
if [ $DELETE_COUNT -gt 50 ]; then
    echo "ALERTE: $DELETE_COUNT suppressions détectées en 1000 dernières requêtes" | \
    mail -s "ALERTE SÉCURITÉ MySQL" $ALERT_EMAIL
fi
```

**Cron (exécution toutes les 5 minutes) :**

```bash
*/5 * * * * /usr/local/bin/monitor_audit.sh
```

---

## 16.9.10 Conformité réglementaire

### ISO 27001 A.12.4.1

**Exigence :** Enregistrement et surveillance des événements.

**Implémentation AtlasTech :**
- Server Audit Plugin actif
- Logs de toutes les connexions
- Logs de toutes les modifications CRUD
- Rétention 1 an

### RGPD Article 30

**Exigence :** Registre des activités de traitement.

**Rapport de conformité :**

```sql
SELECT 
    'Accès aux données personnelles' AS activite,
    COUNT(*) AS nb_operations,
    MIN(timestamp) AS date_debut,
    MAX(timestamp) AS date_fin
FROM logs_audit
WHERE table_name IN ('employes', 'clients')
  AND action = 'SELECT'
  AND timestamp >= DATE_SUB(NOW(), INTERVAL 1 YEAR);
```

---

## Conclusion

L'audit de base de données implémenté dans AtlasTech Solutions :

**Logs activés :**
- General Log (requêtes SQL)
- Server Audit Plugin (connexions, requêtes, tables)
- Table logs_audit (modifications CRUD)
- Table logs_connexion (authentification)

**Événements tracés :**
- 100% des connexions
- 100% des modifications de données
- 100% des requêtes sensibles

**Rétention :**
- 1 an pour logs_audit
- 6 mois pour logs_connexion
- 90 jours pour fichiers audit.log

**Alertes :**
- DROP TABLE
- Connexions root externes
- Suppressions massives
- Tentatives de brute force

**Conformité :**
- ISO 27001 A.12.4.1 : Conforme
- RGPD Article 30 : Conforme

**Prochaine section :** 16.10 Backup & Restore