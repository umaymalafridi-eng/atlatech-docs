---
title: INDEX pour Performance
sidebar_label: "16.4 INDEX Performance"
sidebar_position: 5
---

# 16.4 INDEX pour Performance

## Introduction

Les INDEX sont des structures de données qui accélèrent considérablement les recherches dans une base de données.

### Qu'est-ce qu'un INDEX ?

**Pour les non-techniciens :** Un INDEX est comme l'index d'un livre. Au lieu de lire tout le livre pour trouver un mot, vous consultez l'index qui vous dit directement à quelle page aller.

**Pour les techniciens :** Un INDEX est une structure de données B-Tree qui permet des recherches en O(log n) au lieu de O(n) sur une table.

---

## 16.4.1 État AVANT (Sans INDEX)

### Problème : Recherches lentes

**Test de performance sans INDEX :**

```sql
-- Créer une table de test sans INDEX
CREATE TABLE employes_test (
    id INT AUTO_INCREMENT PRIMARY KEY,
    nom VARCHAR(100),
    prenom VARCHAR(100),
    departement VARCHAR(50),
    salaire DECIMAL(10,2)
) ENGINE=InnoDB;

-- Insérer 100000 enregistrements
DELIMITER $$
CREATE PROCEDURE insert_test_data()
BEGIN
    DECLARE i INT DEFAULT 1;
    WHILE i <= 100000 DO
        INSERT INTO employes_test (nom, prenom, departement, salaire)
        VALUES (
            CONCAT('Nom', i),
            CONCAT('Prenom', i),
            ELT(MOD(i, 6) + 1, 'IT', 'RH', 'Finance', 'Commercial', 'Dev', 'Direction'),
            ROUND(RAND() * 50000 + 10000, 2)
        );
        SET i = i + 1;
    END WHILE;
END$$
DELIMITER ;

CALL insert_test_data();

-- Recherche sans INDEX
EXPLAIN SELECT * FROM employes_test WHERE departement = 'IT';
```

**Résultat EXPLAIN :**

| type | possible_keys | key | rows | Extra |
|------|---------------|-----|------|-------|
| ALL | NULL | NULL | 100000 | Using where |

**Type = ALL** signifie un **Full Table Scan** (lecture de toutes les lignes).

**Temps d'exécution :** 2.5 secondes pour 100000 lignes.

---

## 16.4.2 État APRÈS (Avec INDEX)

### Création d'INDEX

**INDEX simple sur departement :**

```sql
CREATE INDEX idx_departement ON employes_test(departement);

-- Même requête
EXPLAIN SELECT * FROM employes_test WHERE departement = 'IT';
```

**Résultat EXPLAIN :**

| type | possible_keys | key | rows | Extra |
|------|---------------|-----|------|-------|
| ref | idx_departement | idx_departement | 16667 | Using index condition |

**Type = ref** : Utilisation de l'INDEX pour accéder directement aux lignes.

**Temps d'exécution :** 0.03 secondes (83x plus rapide !).

### INDEX sur AtlasTech

#### Table employes

```sql
-- INDEX sur colonnes de recherche fréquente
CREATE INDEX idx_employes_nom_prenom ON employes(nom, prenom);
CREATE INDEX idx_employes_departement ON employes(departement_id);
CREATE INDEX idx_employes_email ON employes(email);
CREATE INDEX idx_employes_date_embauche ON employes(date_embauche);
```

**Justification :**

| INDEX | Utilisé pour |
|-------|--------------|
| idx_employes_nom_prenom | Recherches par nom dans l'annuaire |
| idx_employes_departement | Filtres par département, GROUP BY |
| idx_employes_email | Authentification, recherche rapide |
| idx_employes_date_embauche | Tri par ancienneté, statistiques RH |

#### Table commandes

```sql
CREATE INDEX idx_commandes_client ON commandes(client_id);
CREATE INDEX idx_commandes_date ON commandes(date_commande);
CREATE INDEX idx_commandes_statut ON commandes(statut);
```

**Requête optimisée :**

```sql
-- Recherche des commandes d'un client
SELECT * FROM commandes WHERE client_id = 5;

EXPLAIN:
type: ref | key: idx_commandes_client | rows: 12
```

#### Table produits

```sql
CREATE INDEX idx_produits_categorie ON produits(categorie);
CREATE INDEX idx_produits_prix ON produits(prix_unitaire);
CREATE INDEX idx_produits_nom ON produits(nom_produit);
```

---

## 16.4.3 INDEX Composites (Multi-colonnes)

### Ordre des colonnes important

**Exemple : Recherche par département et date d'embauche**

```sql
-- INDEX composite
CREATE INDEX idx_dept_date ON employes(departement_id, date_embauche);

-- Cette requête utilise l'INDEX
SELECT * FROM employes 
WHERE departement_id = 2 
AND date_embauche > '2020-01-01';

-- Cette requête aussi (leftmost prefix)
SELECT * FROM employes WHERE departement_id = 2;

-- Cette requête N'utilise PAS l'INDEX (pas leftmost)
SELECT * FROM employes WHERE date_embauche > '2020-01-01';
```

**Règle du Leftmost Prefix :**

Un INDEX composite (A, B, C) peut être utilisé pour :
- WHERE A = x
- WHERE A = x AND B = y
- WHERE A = x AND B = y AND C = z

Mais PAS pour :
- WHERE B = y
- WHERE C = z

### INDEX pour ORDER BY

```sql
-- INDEX optimisant le tri
CREATE INDEX idx_commandes_date_statut ON commandes(date_commande DESC, statut);

-- Cette requête utilise l'INDEX pour le tri
SELECT * FROM commandes 
ORDER BY date_commande DESC, statut;

EXPLAIN:
Extra: Using index
```

---

## 16.4.4 INDEX sur Foreign Keys

**MariaDB crée automatiquement des INDEX sur les Foreign Keys :**

```sql
-- Vérifier les INDEX créés automatiquement
SHOW INDEX FROM employes;
```

**Résultat :**

| Key_name | Column_name | Index_type |
|----------|-------------|------------|
| PRIMARY | employe_id | BTREE |
| fk_employes_departement | departement_id | BTREE |
| uk_employes_email | email | BTREE |

**L'INDEX `fk_employes_departement` est créé automatiquement !**

**Pourquoi ?** Pour accélérer les vérifications d'intégrité référentielle.

---

## 16.4.5 INDEX FULLTEXT pour recherche textuelle

### Recherche dans les descriptions

**Création d'INDEX FULLTEXT :**

```sql
-- INDEX FULLTEXT sur description produit
ALTER TABLE produits 
ADD FULLTEXT INDEX ft_description (description);

-- Recherche de mots-clés
SELECT * FROM produits 
WHERE MATCH(description) AGAINST('site web moderne responsive');
```

**Résultat :**

| produit_id | nom_produit | description | score |
|------------|-------------|-------------|-------|
| 1 | Pack Site Vitrine | Site vitrine 5 pages avec design moderne | 2.5 |
| 2 | Site Custom | Site web sur mesure responsive | 1.8 |

**Avantage :** Recherche pertinente avec scoring automatique.

---

## 16.4.6 Analyse de performance

### Commande EXPLAIN

**Structure de EXPLAIN :**

```sql
EXPLAIN SELECT * FROM employes WHERE departement_id = 2;
```

**Colonnes importantes :**

| Colonne | Valeurs | Signification |
|---------|---------|---------------|
| **type** | const | Meilleur : lookup direct par PRIMARY KEY |
| | eq_ref | Très bon : JOIN sur PRIMARY KEY unique |
| | ref | Bon : Utilisation d'INDEX non-unique |
| | range | Moyen : Scan d'un intervalle (BETWEEN, >, \<) |
| | index | Mauvais : Scan complet de l'INDEX |
| | ALL | Très mauvais : Full Table Scan |
| **possible_keys** | idx_nom | INDEX pouvant être utilisés |
| **key** | idx_nom | INDEX réellement utilisé |
| **rows** | 150 | Nombre de lignes examinées (estimation) |
| **Extra** | Using index | Données lues uniquement depuis l'INDEX |

### Requêtes lentes

**Activer le slow query log :**

```sql
-- Activer le log des requêtes lentes
SET GLOBAL slow_query_log = 'ON';
SET GLOBAL long_query_time = 1;  -- Requêtes > 1 seconde

-- Fichier de log
SET GLOBAL slow_query_log_file = '/var/log/mysql/slow-query.log';
```

**Analyser les requêtes lentes :**

```bash
# Résumé des requêtes lentes
mysqldumpslow -s t -t 10 /var/log/mysql/slow-query.log

# Résultat :
Count: 45
Time=5.32s (239s)  Lock=0.00s (0s)  Rows=100000.0 (4500000), root[root]@localhost
  SELECT * FROM employes WHERE departement = 'N'
```

**Solution :** Ajouter un INDEX sur `departement`.

---

## 16.4.7 Optimisation des INDEX

### Statistiques des INDEX

```sql
-- Mise à jour des statistiques
ANALYZE TABLE employes;

-- Vérifier la cardinalité
SHOW INDEX FROM employes;
```

**Résultat :**

| Key_name | Cardinality | Comment |
|----------|-------------|---------|
| PRIMARY | 25 | Unique |
| idx_email | 25 | Unique |
| idx_departement | 6 | 6 valeurs distinctes |
| idx_nom_prenom | 25 | Unique |

**Cardinalité faible = INDEX peu sélectif = moins utile.**

### INDEX inutilisés

**Détecter les INDEX jamais utilisés :**

```sql
SELECT 
    OBJECT_SCHEMA,
    OBJECT_NAME,
    INDEX_NAME,
    COUNT_STAR as nb_utilisations
FROM performance_schema.table_io_waits_summary_by_index_usage
WHERE OBJECT_SCHEMA = 'atlastech_db'
  AND INDEX_NAME IS NOT NULL
  AND COUNT_STAR = 0;
```

**Résultat :**

| OBJECT_NAME | INDEX_NAME | nb_utilisations |
|-------------|------------|-----------------|
| employes | idx_date_embauche | 0 |

**Action :** Supprimer l'INDEX inutilisé.

```sql
DROP INDEX idx_date_embauche ON employes;
```

---

## 16.4.8 Taille des INDEX

### Calculer l'espace disque

```sql
SELECT 
    TABLE_NAME,
    INDEX_NAME,
    ROUND(STAT_VALUE * @@innodb_page_size / 1024 / 1024, 2) AS size_mb
FROM mysql.innodb_index_stats
WHERE DATABASE_NAME = 'atlastech_db'
  AND STAT_NAME = 'size'
ORDER BY STAT_VALUE DESC;
```

**Résultat :**

| TABLE_NAME | INDEX_NAME | size_mb |
|------------|------------|---------|
| employes | PRIMARY | 0.25 |
| employes | idx_email | 0.15 |
| commandes | idx_date | 1.8 |
| produits | ft_description | 2.3 |

**Total INDEX :** 4.5 MB (acceptable pour 100000+ enregistrements).

---

## 16.4.9 INDEX couvrants (Covering Index)

### Optimisation ultime

**INDEX couvrant = INDEX contenant toutes les colonnes de la requête**

```sql
-- Requête fréquente
SELECT nom, prenom, email FROM employes WHERE departement_id = 2;

-- INDEX couvrant
CREATE INDEX idx_covering ON employes(departement_id, nom, prenom, email);

EXPLAIN SELECT nom, prenom, email FROM employes WHERE departement_id = 2;
```

**Résultat :**

| type | key | Extra |
|------|-----|-------|
| ref | idx_covering | **Using index** |

**"Using index"** = Les données sont lues UNIQUEMENT depuis l'INDEX, sans accéder à la table.

**Gain de performance :** 3-5x plus rapide.

---

## 16.4.10 Bonnes pratiques

### Quand créer un INDEX

| Situation | Créer INDEX ? |
|-----------|--------------|
| Colonne utilisée dans WHERE | Oui |
| Colonne utilisée dans JOIN | Oui (automatique pour FK) |
| Colonne utilisée dans ORDER BY | Oui |
| Colonne utilisée dans GROUP BY | Oui |
| Colonne avec peu de valeurs distinctes | Non (cardinalité faible) |
| Petite table (\< 1000 lignes) | Non (inutile) |

### INDEX à éviter

**Erreur 1 : Trop d'INDEX**

```sql
-- MAUVAIS : 10 INDEX sur une table de 100 lignes
CREATE INDEX idx1 ON petite_table(col1);
CREATE INDEX idx2 ON petite_table(col2);
...
CREATE INDEX idx10 ON petite_table(col10);

-- Impact : INSERT/UPDATE très lents (mise à jour de 10 INDEX)
```

**Règle :** Maximum 5-7 INDEX par table.

**Erreur 2 : INDEX redondants**

```sql
-- INDEX redondants
CREATE INDEX idx_nom ON employes(nom);
CREATE INDEX idx_nom_prenom ON employes(nom, prenom);

-- idx_nom est redondant car idx_nom_prenom peut être utilisé pour WHERE nom = 'X'
```

**Solution :** Garder uniquement `idx_nom_prenom`.

---

## Conclusion

Les INDEX implémentés dans AtlasTech Solutions :

**Performance :**
- Requêtes 50-100x plus rapides sur tables volumineuses
- Temps de réponse \< 50ms pour 99% des requêtes

**INDEX créés :**
- 12 INDEX simples
- 4 INDEX composites
- 2 INDEX FULLTEXT
- Total : 18 INDEX sur 8 tables

**Espace disque :** 4.5 MB (négligeable)

**Prochaine section :** 16.5 Types de Données Sécurisés