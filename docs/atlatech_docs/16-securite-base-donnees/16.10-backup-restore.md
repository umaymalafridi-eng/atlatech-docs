---
title: Backup & Restore
sidebar_label: "16.10 Backup & Restore"
sidebar_position: 11
---

# 16.10 Backup & Restore

## Introduction

Les backups (sauvegardes) protègent contre la perte de données due aux pannes matérielles, erreurs humaines, ou attaques (ransomware).

### Pourquoi faire des backups ?

**Pour les non-techniciens :** Un backup est comme une photocopie de tous vos documents importants. Si l'original est perdu ou détruit, vous avez toujours la copie.

**Pour les techniciens :** Un backup est une copie cohérente des données permettant la restauration complète ou partielle du système en cas de sinistre.

---

## 16.10.1 Stratégie de backup

### Règle 3-2-1

**3 copies** des données :
- 1 copie en production (base active)
- 2 copies de sauvegarde

**2 supports** différents :
- Disque local
- Stockage distant (NAS, Cloud)

**1 copie hors site** :
- Protection contre incendie, inondation

### Types de backups

| Type | Contenu | Taille | Temps restauration |
|------|---------|--------|-------------------|
| **Full** | Toute la base | 100% | Rapide (1 fichier) |
| **Incrémental** | Changements depuis dernier backup | 5-10% | Lent (plusieurs fichiers) |
| **Différentiel** | Changements depuis dernier Full | 20-50% | Moyen (2 fichiers) |

### Planning AtlasTech

| Jour | Type | Heure | Rétention |
|------|------|-------|-----------|
| **Dimanche** | Full | 02:00 | 4 semaines |
| **Lundi-Samedi** | Incrémental | 02:00 | 7 jours |

**RPO (Recovery Point Objective) :** 24 heures maximum  
**RTO (Recovery Time Objective) :** 4 heures maximum

---

## 16.10.2 Backup Full avec mysqldump

### Script de backup complet

**Fichier : `/usr/local/bin/backup_database.sh`**

```bash
#!/bin/bash
#############################################
# Script de backup MariaDB AtlasTech
# Full backup avec chiffrement AES-256
#############################################

# Configuration
DB_NAME="atlastech_db"
DB_USER="backup_user"
DB_PASS_FILE="/root/.mysql_backup_password"
BACKUP_DIR="/backups/database"
ENCRYPTION_KEY_FILE="/root/.backup_encryption_key"
DATE=$(date +%Y%m%d_%H%M%S)
BACKUP_FILE="$BACKUP_DIR/atlastech_db_full_$DATE.sql.gz.enc"
LOG_FILE="/var/log/mysql_backup.log"

# Créer le répertoire si nécessaire
mkdir -p $BACKUP_DIR

# Fonction de log
log() {
    echo "[$(date '+%Y-%m-%d %H:%M:%S')] $1" | tee -a $LOG_FILE
}

log "Début du backup full"

# Backup avec mysqldump
mysqldump -u $DB_USER -p$(cat $DB_PASS_FILE) \
    --single-transaction \
    --routines \
    --triggers \
    --events \
    --hex-blob \
    --set-gtid-purged=OFF \
    $DB_NAME 2>> $LOG_FILE | \
gzip | \
openssl enc -aes-256-cbc -salt -pbkdf2 \
    -pass file:$ENCRYPTION_KEY_FILE \
    -out $BACKUP_FILE

# Vérifier le succès
if [ $? -eq 0 ]; then
    SIZE=$(du -h $BACKUP_FILE | cut -f1)
    log "Backup réussi : $BACKUP_FILE ($SIZE)"
    
    # Vérifier l'intégrité
    openssl enc -aes-256-cbc -d -pbkdf2 \
        -pass file:$ENCRYPTION_KEY_FILE \
        -in $BACKUP_FILE | gunzip | head -n 5 > /dev/null 2>&1
    
    if [ $? -eq 0 ]; then
        log "Vérification intégrité : OK"
    else
        log "ERREUR: Backup corrompu"
        exit 1
    fi
else
    log "ERREUR: Échec du backup"
    exit 1
fi

# Suppression des backups > 30 jours
find $BACKUP_DIR -name "*.sql.gz.enc" -mtime +30 -delete
log "Nettoyage des backups anciens terminé"

log "Backup terminé avec succès"
```

### Configuration initiale

**Créer l'utilisateur de backup :**

```sql
CREATE USER 'backup_user'@'localhost' 
IDENTIFIED BY 'BackupSecure!2026Pass';

GRANT SELECT, LOCK TABLES, SHOW VIEW, EVENT, TRIGGER 
ON atlastech_db.* 
TO 'backup_user'@'localhost';

FLUSH PRIVILEGES;
```

**Stocker le mot de passe de manière sécurisée :**

```bash
echo "BackupSecure!2026Pass" > /root/.mysql_backup_password
chmod 600 /root/.mysql_backup_password
```

**Générer la clé de chiffrement :**

```bash
openssl rand -base64 32 > /root/.backup_encryption_key
chmod 600 /root/.backup_encryption_key

# Sauvegarder cette clé dans un coffre-fort physique !
cat /root/.backup_encryption_key
```

### Automatisation avec cron

```bash
# Éditer le crontab
crontab -e

# Ajouter la ligne pour backup quotidien à 2h du matin
0 2 * * * /usr/local/bin/backup_database.sh
```

### Test du backup

```bash
# Exécution manuelle
/usr/local/bin/backup_database.sh

# Vérifier le log
tail -f /var/log/mysql_backup.log
```

**Résultat attendu :**

```
[2026-02-09 14:45:00] Début du backup full
[2026-02-09 14:45:35] Backup réussi : /backups/database/atlastech_db_full_20260209_144500.sql.gz.enc (2.3M)
[2026-02-09 14:45:36] Vérification intégrité : OK
[2026-02-09 14:45:36] Nettoyage des backups anciens terminé
[2026-02-09 14:45:36] Backup terminé avec succès
```

---

## 16.10.3 Backup incrémental avec Binary Logs

### Activation des Binary Logs

**Configuration MariaDB :**

```ini
# /etc/mysql/mariadb.conf.d/50-server.cnf

[mysqld]
# Binary logging pour réplication et PITR
log_bin = /var/log/mysql/mysql-bin
binlog_format = ROW
expire_logs_days = 7
max_binlog_size = 100M
```

**Redémarrer MariaDB :**

```bash
systemctl restart mariadb
```

**Vérification :**

```sql
SHOW VARIABLES LIKE 'log_bin%';
```

**Résultat :**

| Variable_name | Value |
|---------------|-------|
| log_bin | ON |
| log_bin_basename | /var/log/mysql/mysql-bin |

### Sauvegarde des Binary Logs

**Script : `/usr/local/bin/backup_binlogs.sh`**

```bash
#!/bin/bash
# Backup des binary logs

BINLOG_DIR="/var/log/mysql"
BACKUP_DIR="/backups/binlogs"
DATE=$(date +%Y%m%d)

mkdir -p $BACKUP_DIR/$DATE

# Copier les binary logs
cp $BINLOG_DIR/mysql-bin.* $BACKUP_DIR/$DATE/

# Flush les logs (créer un nouveau binlog)
mysql -u root -p -e "FLUSH BINARY LOGS;"

echo "Binary logs sauvegardés : $BACKUP_DIR/$DATE"
```

---

## 16.10.4 Restauration complète (Full Restore)

### Procédure de restauration

**Étape 1 : Arrêter l'application**

```bash
systemctl stop apache2
```

**Étape 2 : Déchiffrer le backup**

```bash
BACKUP_FILE="/backups/database/atlastech_db_full_20260209_144500.sql.gz.enc"

openssl enc -aes-256-cbc -d -pbkdf2 \
    -pass file:/root/.backup_encryption_key \
    -in $BACKUP_FILE \
    -out /tmp/restore.sql.gz

gunzip /tmp/restore.sql.gz
```

**Étape 3 : Restaurer la base**

```bash
# Supprimer la base existante
mysql -u root -p -e "DROP DATABASE IF EXISTS atlastech_db;"
mysql -u root -p -e "CREATE DATABASE atlastech_db CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci;"

# Importer le backup
mysql -u root -p atlastech_db < /tmp/restore.sql

# Vérifier
mysql -u root -p atlastech_db -e "SHOW TABLES;"
```

**Résultat :**

```
+-------------------------+
| Tables_in_atlastech_db |
+-------------------------+
| clients                 |
| commandes               |
| conges                  |
| departements            |
| details_commande        |
| employes                |
| produits                |
| salaires                |
+-------------------------+
```

**Étape 4 : Vérifier les données**

```sql
SELECT COUNT(*) AS nb_employes FROM employes;
SELECT COUNT(*) AS nb_commandes FROM commandes;
SELECT COUNT(*) AS nb_produits FROM produits;
```

**Étape 5 : Redémarrer l'application**

```bash
systemctl start apache2
```

---

## 16.10.5 Point-in-Time Recovery (PITR)

### Scénario : Restaurer à un instant précis

**Situation :** Suppression accidentelle de données à 14h30, dernier backup full à 02h00.

**Solution :** Restaurer le backup full + rejouer les binary logs jusqu'à 14h29.

**Étape 1 : Restaurer le full backup**

```bash
mysql -u root -p atlastech_db < /tmp/restore.sql
```

**Étape 2 : Identifier les binary logs à rejouer**

```bash
ls -lh /var/log/mysql/mysql-bin.*
```

**Résultat :**

```
-rw-rw---- 1 mysql mysql 45M Feb  9 06:00 mysql-bin.000001
-rw-rw---- 1 mysql mysql 78M Feb  9 12:00 mysql-bin.000002
-rw-rw---- 1 mysql mysql 23M Feb  9 14:35 mysql-bin.000003
```

**Étape 3 : Rejouer les logs jusqu'à 14:29**

```bash
mysqlbinlog \
    --start-datetime="2026-02-09 02:00:00" \
    --stop-datetime="2026-02-09 14:29:00" \
    /var/log/mysql/mysql-bin.000001 \
    /var/log/mysql/mysql-bin.000002 \
    /var/log/mysql/mysql-bin.000003 | \
mysql -u root -p atlastech_db
```

**Résultat :** Base restaurée à l'état de 14h29, AVANT la suppression accidentelle.

---

## 16.10.6 Tests de restauration

### Planning de tests

| Fréquence | Type de test | Objectif |
|-----------|--------------|----------|
| **Mensuel** | Restauration complète | Vérifier l'intégrité des backups |
| **Trimestriel** | PITR | Valider la procédure de récupération |
| **Annuel** | Disaster Recovery complet | Test sur serveur de secours |

### Script de test automatique

**Fichier : `/usr/local/bin/test_restore.sh`**

```bash
#!/bin/bash
# Test de restauration automatique

TEST_DB="atlastech_db_test"
BACKUP_FILE=$(ls -t /backups/database/atlastech_db_full_*.sql.gz.enc | head -1)
LOG_FILE="/var/log/test_restore.log"

log() {
    echo "[$(date)] $1" | tee -a $LOG_FILE
}

log "Début du test de restauration"
log "Fichier: $BACKUP_FILE"

# Créer une base de test
mysql -u root -p -e "DROP DATABASE IF EXISTS $TEST_DB;"
mysql -u root -p -e "CREATE DATABASE $TEST_DB;"

# Restaurer
openssl enc -aes-256-cbc -d -pbkdf2 \
    -pass file:/root/.backup_encryption_key \
    -in $BACKUP_FILE | \
gunzip | \
mysql -u root -p $TEST_DB

# Vérifier
TABLE_COUNT=$(mysql -u root -p -N -e "SELECT COUNT(*) FROM information_schema.tables WHERE table_schema='$TEST_DB';")

if [ $TABLE_COUNT -eq 8 ]; then
    log "Test RÉUSSI : $TABLE_COUNT tables restaurées"
else
    log "Test ÉCHOUÉ : $TABLE_COUNT tables (attendu: 8)"
fi

# Nettoyer
mysql -u root -p -e "DROP DATABASE $TEST_DB;"

log "Test terminé"
```

**Cron (exécution mensuelle) :**

```bash
0 3 1 * * /usr/local/bin/test_restore.sh
```

---

## 16.10.7 Backup vers stockage distant

### Synchronisation avec rsync

**Script : `/usr/local/bin/sync_backups.sh`**

```bash
#!/bin/bash
# Synchronisation des backups vers NAS

LOCAL_BACKUP_DIR="/backups/database"
REMOTE_BACKUP_DIR="backup@192.168.10.30:/backups/atlastech/database"
SSH_KEY="/root/.ssh/backup_key"

rsync -avz --delete \
    -e "ssh -i $SSH_KEY" \
    $LOCAL_BACKUP_DIR/ \
    $REMOTE_BACKUP_DIR

if [ $? -eq 0 ]; then
    echo "Synchronisation réussie vers NAS"
else
    echo "ERREUR: Échec de la synchronisation"
    exit 1
fi
```

**Cron (exécution après chaque backup) :**

```bash
15 2 * * * /usr/local/bin/sync_backups.sh
```

### Backup vers Cloud (AWS S3)

```bash
#!/bin/bash
# Upload vers AWS S3

BACKUP_FILE=$(ls -t /backups/database/atlastech_db_full_*.sql.gz.enc | head -1)
S3_BUCKET="s3://atlastech-backups/database/"

aws s3 cp $BACKUP_FILE $S3_BUCKET \
    --storage-class GLACIER \
    --server-side-encryption AES256

echo "Backup uploadé vers S3 : $BACKUP_FILE"
```

---

## 16.10.8 Réplication Master-Slave (déjà vu chapitre 11)

### Avantages pour le backup

**Backup sur le Slave = ZERO impact sur le Master**

```bash
# Backup depuis le slave
mysqldump -u backup_user -p \
    --single-transaction \
    --master-data=2 \
    -h 192.168.10.21 \
    atlastech_db > /backups/from_slave.sql
```

**Aucune charge CPU/IO sur le serveur de production !**

---

## 16.10.9 Monitoring des backups

### Surveillance automatique

**Script : `/usr/local/bin/monitor_backups.sh`**

```bash
#!/bin/bash
# Vérifier que les backups sont bien créés

BACKUP_DIR="/backups/database"
ALERT_EMAIL="admin@atlastech.ma"
MAX_AGE_HOURS=26  # Alerte si backup > 26h

# Dernier backup
LAST_BACKUP=$(ls -t $BACKUP_DIR/atlastech_db_full_*.sql.gz.enc 2>/dev/null | head -1)

if [ -z "$LAST_BACKUP" ]; then
    echo "ALERTE: Aucun backup trouvé" | \
    mail -s "ALERTE BACKUP MySQL" $ALERT_EMAIL
    exit 1
fi

# Âge du backup
AGE_HOURS=$(( ($(date +%s) - $(stat -c %Y "$LAST_BACKUP")) / 3600 ))

if [ $AGE_HOURS -gt $MAX_AGE_HOURS ]; then
    echo "ALERTE: Dernier backup vieux de $AGE_HOURS heures (max: $MAX_AGE_HOURS)" | \
    mail -s "ALERTE BACKUP MySQL" $ALERT_EMAIL
    exit 1
fi

echo "OK: Backup récent ($AGE_HOURS heures)"
```

**Cron (vérification toutes les heures) :**

```bash
0 * * * * /usr/local/bin/monitor_backups.sh
```

---

## 16.10.10 Documentation de la procédure de restauration

### Runbook de Disaster Recovery

**Fichier : `/root/DISASTER_RECOVERY_RUNBOOK.md`**

```markdown
# Procédure de Disaster Recovery - AtlasTech Solutions

## Contact d'urgence
- Responsable IT : Oumayma Lafridi - 06-XX-XX-XX-XX
- DBA : Ibtissam Elghbali - 06-YY-YY-YY-YY

## Emplacements des backups
- Local : /backups/database/
- NAS : backup@192.168.10.30:/backups/atlastech/
- Cloud : s3://atlastech-backups/database/

## Clés de chiffrement
- Emplacement : /root/.backup_encryption_key
- Copie physique : Coffre-fort bureau direction

## Procédure de restauration complète

### 1. Arrêter les services
```bash
systemctl stop apache2
systemctl stop mariadb
```

### 2. Déchiffrer et restaurer
```bash
BACKUP=/backups/database/atlastech_db_full_YYYYMMDD_HHMMSS.sql.gz.enc
openssl enc -aes-256-cbc -d -pbkdf2 -pass file:/root/.backup_encryption_key -in $BACKUP | gunzip | mysql -u root -p atlastech_db
```

### 3. Vérifier l'intégrité
```bash
mysql -u root -p atlastech_db -e "SELECT COUNT(*) FROM employes;"
mysql -u root -p atlastech_db -e "SELECT COUNT(*) FROM commandes;"
```

### 4. Redémarrer les services
```bash
systemctl start mariadb
systemctl start apache2
```

### 5. Tester l'application
- URL : http://192.168.112.141/atlastech/
- Login : admin / [voir gestionnaire de mots de passe]

## RTO/RPO
- RTO : 4 heures maximum
- RPO : 24 heures maximum

## Dernière mise à jour
2026-02-09
```

---

## 16.10.11 Checklist de conformité

### ISO 27001 A.12.3.1

**Exigence :** Sauvegarde de l'information.

**Implémentation AtlasTech :**
- ✓ Backup quotidien automatique
- ✓ Chiffrement AES-256
- ✓ Stockage sur 2 supports (local + distant)
- ✓ Tests mensuels de restauration
- ✓ Documentation à jour

### RGPD Article 32

**Exigence :** Capacité de restaurer la disponibilité des données.

**Implémentation AtlasTech :**
- ✓ RPO : 24 heures
- ✓ RTO : 4 heures
- ✓ Backups chiffrés
- ✓ Procédure documentée

---

## Conclusion

La stratégie de backup et restore d'AtlasTech Solutions garantit :

**Protection :**
- Backups quotidiens automatiques
- Chiffrement AES-256
- Réplication sur 3 emplacements (local, NAS, Cloud)

**Récupération :**
- Restauration complète en 4h maximum
- Point-in-Time Recovery avec Binary Logs
- Perte de données maximale : 24h (RPO)

**Tests :**
- Restauration testée mensuellement
- PITR testé trimestriellement
- Disaster Recovery testé annuellement

**Conformité :**
- ISO 27001 A.12.3.1 : Conforme
- RGPD Article 32 : Conforme

**Automatisation :**
- Backup : Automatique (cron)
- Synchronisation : Automatique
- Monitoring : Alertes automatiques

---

## Fin du chapitre 16

Ce chapitre complète la sécurisation de la base de données AtlasTech Solutions avec 10 sections couvrant tous les aspects de la sécurité base de données :

1. Schéma structuré et normalisé
2. Intégrité référentielle (Foreign Keys)
3. Contraintes d'unicité (UNIQUE)
4. Performance (INDEX)
5. Types de données appropriés
6. Procédures stockées sécurisées
7. Privilèges granulaires
8. Chiffrement des données sensibles
9. Audit complet
10. Backup et restauration

**Résultat :** Base de données sécurisée, performante, auditable et résiliente.