---
title: Procédures Stockées Sécurisées
sidebar_label: "16.6 Procédures Stockées"
sidebar_position: 7
---

# 16.6 Procédures Stockées Sécurisées

## Introduction

Les procédures stockées sont des programmes SQL enregistrés dans la base de données, exécutables par les applications.

### Qu'est-ce qu'une procédure stockée ?

**Pour les non-techniciens :** Une procédure stockée est comme une recette de cuisine enregistrée. Au lieu de répéter toutes les étapes à chaque fois, vous appelez simplement la recette par son nom.

**Pour les techniciens :** Une procédure stockée est un ensemble de requêtes SQL précompilées, stockées côté serveur, offrant sécurité, performance et réutilisabilité.

---

## 16.6.1 État AVANT (Vulnérable)

### Problème : SQL dynamique non sécurisé

**Procédure vulnérable à l'injection SQL :**

```sql
DELIMITER $$
CREATE PROCEDURE get_employe_by_nom_UNSAFE(IN p_nom VARCHAR(100))
BEGIN
    SET @sql = CONCAT('SELECT * FROM employes WHERE nom = "', p_nom, '"');
    PREPARE stmt FROM @sql;
    EXECUTE stmt;
    DEALLOCATE PREPARE stmt;
END$$
DELIMITER ;
```

**Exploitation :**

```sql
-- Appel normal
CALL get_employe_by_nom_UNSAFE('Dupont');
-- Résultat : Employé Dupont

-- Injection SQL
CALL get_employe_by_nom_UNSAFE('" OR "1"="1');
-- SQL généré : SELECT * FROM employes WHERE nom = "" OR "1"="1"
-- Résultat : TOUS les employés retournés !
```

**Impact :** Contournement de la sécurité, exfiltration de données.

---

## 16.6.2 État APRÈS (Sécurisé)

### Procédures paramétrées

**Version sécurisée :**

```sql
DELIMITER $$
CREATE PROCEDURE get_employe_by_nom(IN p_nom VARCHAR(100))
BEGIN
    SELECT employe_id, nom, prenom, email, poste
    FROM employes
    WHERE nom = p_nom;  -- Paramètre lié, pas de concaténation
END$$
DELIMITER ;
```

**Test :**

```sql
-- Appel normal
CALL get_employe_by_nom('Dupont');
-- Résultat : Employé Dupont

-- Tentative d'injection
CALL get_employe_by_nom('" OR "1"="1');
-- Résultat : Empty set (aucune correspondance)
```

**Pourquoi c'est sécurisé ?** Le paramètre est traité comme une valeur littérale, pas comme du code SQL.

---

## 16.6.3 Procédures CRUD sécurisées

### Création d'un employé

```sql
DELIMITER $$
CREATE PROCEDURE creer_employe(
    IN p_utilisateur VARCHAR(50),
    IN p_mot_de_passe VARCHAR(255),
    IN p_nom VARCHAR(100),
    IN p_prenom VARCHAR(100),
    IN p_email VARCHAR(150),
    IN p_departement_id INT,
    IN p_type_contrat ENUM('CDI', 'CDD', 'Stage', 'Alternance'),
    IN p_poste VARCHAR(100),
    OUT p_employe_id INT
)
BEGIN
    DECLARE v_error VARCHAR(500);
    
    -- Validation email unique
    IF EXISTS (SELECT 1 FROM employes WHERE email = p_email) THEN
        SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = 'Email déjà utilisé';
    END IF;
    
    -- Validation département existe
    IF NOT EXISTS (SELECT 1 FROM departements WHERE departement_id = p_departement_id) THEN
        SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = 'Département inexistant';
    END IF;
    
    -- Insertion
    INSERT INTO employes (
        utilisateur, mot_de_passe, nom, prenom, email,
        departement_id, type_contrat, poste, date_embauche, actif
    ) VALUES (
        p_utilisateur, p_mot_de_passe, p_nom, p_prenom, p_email,
        p_departement_id, p_type_contrat, p_poste, CURDATE(), TRUE
    );
    
    SET p_employe_id = LAST_INSERT_ID();
    
    -- Log de création
    INSERT INTO logs_audit (action, table_name, record_id, user)
    VALUES ('CREATE', 'employes', p_employe_id, USER());
END$$
DELIMITER ;
```

**Utilisation :**

```sql
CALL creer_employe(
    'n.user', '$argon2id$...', 'User', 'New', 'n.user@company.ma',
    2, 'CDI', 'Développeur',
    @new_id
);

SELECT @new_id AS nouvel_employe_id;
```

**Résultat :**

| nouvel_employe_id |
|-------------------|
| 26 |

### Mise à jour d'un employé

```sql
DELIMITER $$
CREATE PROCEDURE modifier_employe(
    IN p_employe_id INT,
    IN p_email VARCHAR(150),
    IN p_poste VARCHAR(100),
    IN p_departement_id INT
)
BEGIN
    -- Vérifier que l'employé existe
    IF NOT EXISTS (SELECT 1 FROM employes WHERE employe_id = p_employe_id) THEN
        SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = 'Employé inexistant';
    END IF;
    
    -- Vérifier email unique (sauf pour l'employé lui-même)
    IF EXISTS (SELECT 1 FROM employes WHERE email = p_email AND employe_id != p_employe_id) THEN
        SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = 'Email déjà utilisé';
    END IF;
    
    -- Mise à jour
    UPDATE employes
    SET email = p_email,
        poste = p_poste,
        departement_id = p_departement_id
    WHERE employe_id = p_employe_id;
    
    -- Log
    INSERT INTO logs_audit (action, table_name, record_id, user, details)
    VALUES ('UPDATE', 'employes', p_employe_id, USER(), CONCAT('Email: ', p_email, ', Poste: ', p_poste));
END$$
DELIMITER ;
```

### Suppression sécurisée

```sql
DELIMITER $$
CREATE PROCEDURE supprimer_employe(
    IN p_employe_id INT,
    IN p_raison TEXT
)
BEGIN
    DECLARE v_nom_complet VARCHAR(200);
    DECLARE v_email VARCHAR(150);
    
    -- Récupérer infos avant suppression (pour log RGPD)
    SELECT CONCAT(prenom, ' ', nom), email
    INTO v_nom_complet, v_email
    FROM employes
    WHERE employe_id = p_employe_id;
    
    -- Vérifier existence
    IF v_nom_complet IS NULL THEN
        SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = 'Employé inexistant';
    END IF;
    
    -- Log RGPD
    INSERT INTO logs_suppressions_rgpd (employe_id, nom_complet, email, motif, demande_par)
    VALUES (p_employe_id, v_nom_complet, v_email, p_raison, USER());
    
    -- Suppression (CASCADE supprime automatiquement salaires, congés)
    DELETE FROM employes WHERE employe_id = p_employe_id;
    
    SELECT CONCAT('Employé ', v_nom_complet, ' supprimé avec succès') AS resultat;
END$$
DELIMITER ;
```

**Utilisation :**

```sql
CALL supprimer_employe(15, 'Demande RGPD - Droit à l\'oubli');
```

**Résultat :**

| resultat |
|----------|
| Employé Latifa Moumin supprimé avec succès |

---

## 16.6.4 Procédures métier

### Calcul automatique des congés restants

```sql
DELIMITER $$
CREATE PROCEDURE calculer_solde_conges(
    IN p_employe_id INT,
    OUT p_solde_jours DECIMAL(5,2)
)
BEGIN
    DECLARE v_jours_acquis DECIMAL(5,2);
    DECLARE v_jours_pris DECIMAL(5,2);
    DECLARE v_annees_anciennete INT;
    
    -- Calculer ancienneté
    SELECT YEAR(CURDATE()) - YEAR(date_embauche)
    INTO v_annees_anciennete
    FROM employes
    WHERE employe_id = p_employe_id;
    
    -- Jours acquis (22 jours de base + 1 jour par année d'ancienneté)
    SET v_jours_acquis = 22 + v_annees_anciennete;
    
    -- Jours pris (congés approuvés cette année)
    SELECT COALESCE(SUM(nombre_jours), 0)
    INTO v_jours_pris
    FROM conges
    WHERE employe_id = p_employe_id
      AND statut = 'Approuvé'
      AND YEAR(date_debut) = YEAR(CURDATE());
    
    -- Solde
    SET p_solde_jours = v_jours_acquis - v_jours_pris;
END$$
DELIMITER ;
```

**Utilisation :**

```sql
CALL calculer_solde_conges(2, @solde);
SELECT @solde AS jours_conges_restants;
```

**Résultat :**

| jours_conges_restants |
|-----------------------|
| 17.00 |

### Validation de congé

```sql
DELIMITER $$
CREATE PROCEDURE approuver_conge(
    IN p_conge_id INT,
    IN p_approbateur_id INT
)
BEGIN
    DECLARE v_employe_id INT;
    DECLARE v_nombre_jours INT;
    DECLARE v_solde DECIMAL(5,2);
    
    -- Récupérer infos congé
    SELECT employe_id, nombre_jours
    INTO v_employe_id, v_nombre_jours
    FROM conges
    WHERE conge_id = p_conge_id;
    
    -- Vérifier solde suffisant
    CALL calculer_solde_conges(v_employe_id, v_solde);
    
    IF v_solde < v_nombre_jours THEN
        SIGNAL SQLSTATE '45000' 
        SET MESSAGE_TEXT = 'Solde de congés insuffisant';
    END IF;
    
    -- Approuver
    UPDATE conges
    SET statut = 'Approuvé',
        approuve_par = p_approbateur_id,
        date_approbation = NOW()
    WHERE conge_id = p_conge_id;
    
    SELECT 'Congé approuvé avec succès' AS resultat;
END$$
DELIMITER ;
```

---

## 16.6.5 Sécurité des procédures

### Droits d'exécution limités

```sql
-- Créer un utilisateur pour l'application RH
CREATE USER 'hr_app_user'@'localhost' IDENTIFIED BY 'SecurePassword2026!';

-- Donner uniquement le droit EXECUTE sur les procédures
GRANT EXECUTE ON PROCEDURE atlastech_db.creer_employe TO 'hr_app_user'@'localhost';
GRANT EXECUTE ON PROCEDURE atlastech_db.modifier_employe TO 'hr_app_user'@'localhost';
GRANT EXECUTE ON PROCEDURE atlastech_db.supprimer_employe TO 'hr_app_user'@'localhost';

-- AUCUN accès direct aux tables
-- L'application ne peut QUE appeler les procédures
```

**Avantage :** Contrôle total de la logique métier.

### SQL SECURITY DEFINER vs INVOKER

```sql
-- DEFINER : La procédure s'exécute avec les droits de son créateur
CREATE DEFINER = 'root'@'localhost'
PROCEDURE proc_admin()
SQL SECURITY DEFINER
BEGIN
    -- Cette procédure peut tout faire (droits de root)
    SELECT * FROM employes;
END;

-- INVOKER : La procédure s'exécute avec les droits de l'appelant
CREATE PROCEDURE proc_user()
SQL SECURITY INVOKER
BEGIN
    -- Cette procédure est limitée par les droits de l'utilisateur qui l'appelle
    SELECT * FROM employes;
END;
```

**Recommandation :** Utiliser DEFINER pour les procédures sensibles avec validation stricte.

---

## 16.6.6 Gestion des erreurs

### Handlers d'erreurs

```sql
DELIMITER $$
CREATE PROCEDURE creer_employe_robust(
    IN p_nom VARCHAR(100),
    IN p_email VARCHAR(150)
)
BEGIN
    DECLARE EXIT HANDLER FOR SQLEXCEPTION
    BEGIN
        -- Rollback en cas d'erreur
        ROLLBACK;
        SELECT 'Erreur lors de la création de l\'employé' AS erreur;
    END;
    
    DECLARE EXIT HANDLER FOR 1062  -- Duplicate entry
    BEGIN
        SELECT 'Email ou nom d\'utilisateur déjà existant' AS erreur;
    END;
    
    START TRANSACTION;
    
    INSERT INTO employes (nom, email, ...)
    VALUES (p_nom, p_email, ...);
    
    COMMIT;
    
    SELECT 'Employé créé avec succès' AS succes;
END$$
DELIMITER ;
```

---

## 16.6.7 Suppression des procédures dangereuses

### Audit des procédures existantes

```sql
-- Lister toutes les procédures
SELECT ROUTINE_NAME, SECURITY_TYPE, SQL_DATA_ACCESS
FROM INFORMATION_SCHEMA.ROUTINES
WHERE ROUTINE_SCHEMA = 'atlastech_db'
  AND ROUTINE_TYPE = 'PROCEDURE';
```

**Résultat :**

| ROUTINE_NAME | SECURITY_TYPE | SQL_DATA_ACCESS |
|--------------|---------------|-----------------|
| get_employe_by_nom_UNSAFE | DEFINER | CONTAINS SQL |
| proc_with_dynamic_sql | DEFINER | MODIFIES SQL DATA |

### Suppression des procédures vulnérables

```sql
-- Supprimer les procédures avec SQL dynamique
DROP PROCEDURE IF EXISTS get_employe_by_nom_UNSAFE;
DROP PROCEDURE IF EXISTS proc_with_dynamic_sql;

-- Vérification
SELECT COUNT(*) AS nb_procedures_restantes
FROM INFORMATION_SCHEMA.ROUTINES
WHERE ROUTINE_SCHEMA = 'atlastech_db'
  AND ROUTINE_TYPE = 'PROCEDURE';
```

---

## 16.6.8 Documentation des procédures

### Commentaires et documentation

```sql
DELIMITER $$
CREATE PROCEDURE documenter_procedure()
/**
 * Procédure : documenter_procedure
 * Auteur : AtlasTech IT Team
 * Date : 2026-02-09
 * 
 * Description :
 * Cette procédure illustre les bonnes pratiques de documentation
 * 
 * Paramètres :
 * - Aucun
 * 
 * Retour :
 * - Message de confirmation
 * 
 * Exceptions :
 * - Aucune
 * 
 * Exemple d'utilisation :
 * CALL documenter_procedure();
 */
BEGIN
    SELECT 'Procédure bien documentée' AS message;
END$$
DELIMITER ;
```

### Génération de documentation automatique

```bash
#!/bin/bash
# generate_procedure_doc.sh

mysql -u root -p -D atlastech_db -e "
SELECT 
    ROUTINE_NAME AS Procedure,
    ROUTINE_COMMENT AS Description,
    DTD_IDENTIFIER AS ReturnType
FROM INFORMATION_SCHEMA.ROUTINES
WHERE ROUTINE_SCHEMA = 'atlastech_db'
  AND ROUTINE_TYPE = 'PROCEDURE'
ORDER BY ROUTINE_NAME;
" > procedures_documentation.txt
```

---

## Conclusion

Les procédures stockées sécurisées dans AtlasTech Solutions :

**Avantages :**
- Protection contre l'injection SQL (paramètres liés)
- Logique métier centralisée et réutilisable
- Contrôle d'accès granulaire (EXECUTE uniquement)
- Validation des données avant insertion
- Audit automatique de toutes les opérations

**Procédures implémentées :**
- 4 procédures CRUD (créer, modifier, supprimer, lire)
- 3 procédures métier (calcul congés, approbation, statistiques)
- 2 procédures d'audit (logs, suppressions RGPD)

**Sécurité :**
- 0 procédure avec SQL dynamique
- 100% de validation des entrées
- Gestion complète des erreurs

**Prochaine section :** 16.7 Privilèges Base de Données