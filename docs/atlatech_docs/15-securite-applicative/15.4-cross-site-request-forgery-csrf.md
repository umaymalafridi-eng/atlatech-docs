---
id: csrf-protection
title: Protection CSRF (Cross-Site Request Forgery)
sidebar_label: "15.4 Cross-Site Request Forgery (CSRF)"
sidebar_position: 4
---

# 15.4 Protection CSRF (Cross-Site Request Forgery)

## Introduction au CSRF

### Qu'est-ce que le CSRF ?

Le Cross-Site Request Forgery (CSRF ou XSRF) est une attaque qui force un utilisateur authentifié à exécuter des actions non désirées sur une application web dans laquelle il est connecté. L'attaquant exploite la confiance que l'application a envers le navigateur de l'utilisateur.

**Analogie simple :**

Imaginez que vous êtes connecté à votre banque en ligne dans un onglet de votre navigateur. Dans un autre onglet, vous visitez un site malveillant qui contient un formulaire caché. Ce formulaire se soumet automatiquement à votre banque, effectuant un virement sans votre consentement. La banque accepte la requête car votre navigateur envoie automatiquement vos cookies de session.

**Impact d'une attaque CSRF réussie :**

- Modification de données (changement d'email, de mot de passe)
- Suppression de ressources (employés, commandes)
- Transfert de fonds (dans le contexte bancaire)
- Changement de permissions (élévation de privilèges)
- Actions administratives non autorisées

:::danger Classification CSRF
**OWASP Top 10 2021 :** A01:2021 – Broken Access Control (inclut CSRF)
**CWE-352 :** Cross-Site Request Forgery
**CVSS Score :** 6.5 à 8.1 (MEDIUM à HIGH selon l'impact)
:::

---

## Principe de l'Attaque CSRF

### 15.4.1 Scénario d'Attaque Détaillé

**Contexte :** Application CRUD RH d'AtlasTech Solutions

```
Étape 1 : Utilisateur RH légitime (Alice) se connecte
  → Session créée avec cookie PHPSESSID=abc123...
  → Cookie envoyé automatiquement avec chaque requête

Étape 2 : Attaquant crée un site malveillant (evil.com)
  → Contient un formulaire caché qui cible l'application RH
  → Formulaire se soumet automatiquement au chargement de la page

Étape 3 : Alice reçoit un email de phishing
  → "Cliquez ici pour voir votre prime de fin d'année"
  → Lien vers evil.com

Étape 4 : Alice clique sur le lien (toujours connectée à l'appli RH)
  → La page evil.com se charge
  → Le formulaire malveillant se soumet automatiquement

Étape 5 : Le navigateur d'Alice envoie la requête à l'appli RH
  → Inclut automatiquement le cookie PHPSESSID=abc123...
  → L'application RH pense que c'est Alice qui fait l'action
  → L'action malveillante est exécutée (exemple : suppression d'un employé)

Étape 6 : Alice ne remarque rien
  → Aucune interaction visible
  → L'action s'est faite en arrière-plan
```

### 15.4.2 Exemple Concret d'Attaque

**Application RH vulnérable - Suppression d'employé :**

```
Formulaire légitime dans l'application RH :
  https://rh-interne.atlastech.local/employes/supprimer.php

  <form method="POST" action="/employes/supprimer.php">
      <input type="hidden" name="employe_id" value="5">
      <button type="submit">Confirmer la suppression</button>
  </form>
```

**Site malveillant de l'attaquant (evil.com) :**

```html
<!DOCTYPE html>
<html>
<head>
    <title>Vous avez gagné une prime !</title>
</head>
<body>
    <h1>Chargement de votre prime...</h1>
    
    <!-- Formulaire CSRF malveillant (invisible) -->
    <form id="csrf-form" method="POST" 
          action="https://rh-interne.atlastech.local/employes/supprimer.php"
          style="display:none;">
        <input type="hidden" name="employe_id" value="1">
        <!-- L'attaquant supprime l'employé ID=1 (peut-être le directeur) -->
    </form>
    
    <script>
        // Soumission automatique au chargement de la page
        document.getElementById('csrf-form').submit();
    </script>
    
    <p>Redirection en cours...</p>
</body>
</html>
```

**Ce qui se passe :**

```bash
# Requête HTTP envoyée par le navigateur d'Alice :
POST /employes/supprimer.php HTTP/1.1
Host: rh-interne.atlastech.local
Cookie: PHPSESSID=abc123...
Origin: https://evil.com
Referer: https://evil.com/prime.html
Content-Type: application/x-www-form-urlencoded

employe_id=1

# L'application RH reçoit la requête avec un cookie valide
# Elle pense que c'est Alice qui fait la demande
# L'employé ID=1 est supprimé !
```

---

## État Actuel : Code Vulnérable (AVANT)

### 15.4.3 Suppression d'Employé Sans Protection CSRF

**Fichier `/var/www/html/crud-rh/employes/supprimer.php` (VERSION VULNÉRABLE) :**

```php
<?php
session_start();

// Vérification de l'authentification
if (!isset($_SESSION['logged_in']) || $_SESSION['logged_in'] !== true) {
    header("Location: /login.php");
    exit;
}

// Vérification du rôle (admin ou RH uniquement)
if (!in_array($_SESSION['role'], ['admin', 'rh'])) {
    http_response_code(403);
    die("Accès interdit");
}

require_once '../config/database.php';

if ($_SERVER['REQUEST_METHOD'] === 'POST') {
    $employe_id = $_POST['employe_id'] ?? null;
    
    // Validation basique
    if (!filter_var($employe_id, FILTER_VALIDATE_INT)) {
        die("ID employé invalide");
    }
    
    try {
        // VULNÉRABILITÉ : Aucune vérification de l'origine de la requête
        // Aucun token CSRF vérifié
        
        $sql = "DELETE FROM employes WHERE id = :id";
        $stmt = $pdo->prepare($sql);
        $stmt->execute([':id' => $employe_id]);
        
        if ($stmt->rowCount() > 0) {
            $_SESSION['success'] = "Employé supprimé avec succès";
        } else {
            $_SESSION['error'] = "Employé introuvable";
        }
        
        header("Location: /employes/liste.php");
        exit;
        
    } catch (PDOException $e) {
        error_log("Erreur suppression : " . $e->getMessage());
        die("Erreur lors de la suppression");
    }
}
?>
```

**Pourquoi ce code est vulnérable ?**

1. **Pas de token CSRF** : Aucune vérification que la requête provient bien du site légitime
2. **Confiance aveugle dans les cookies** : Le serveur accepte toute requête avec un cookie valide
3. **Pas de vérification de l'origine** : Les headers `Origin` et `Referer` ne sont pas vérifiés
4. **Action destructrice via POST simple** : Peut être déclenchée par n'importe quel site tiers

### 15.4.4 Modification de Salaire Sans Protection

**Fichier `/var/www/html/crud-rh/employes/modifier_salaire.php` (VERSION VULNÉRABLE) :**

```php
<?php
session_start();
require_once '../config/database.php';

// Vérification authentification
if (!isset($_SESSION['logged_in'])) {
    die("Non authentifié");
}

if ($_SERVER['REQUEST_METHOD'] === 'POST') {
    $employe_id = $_POST['employe_id'];
    $nouveau_salaire = $_POST['salaire'];
    
    // VULNÉRABILITÉ CSRF : Pas de token
    // Un attaquant peut augmenter son propre salaire !
    
    $sql = "UPDATE employes SET salaire_mensuel = :salaire WHERE id = :id";
    $stmt = $pdo->prepare($sql);
    $stmt->execute([
        ':salaire' => $nouveau_salaire,
        ':id' => $employe_id
    ]);
    
    echo "Salaire modifié";
}
?>
```

**Exploitation par un attaquant interne :**

```html
<!-- Page malveillante hébergée sur un serveur externe -->
<!DOCTYPE html>
<html>
<head><title>Formulaire d'augmentation automatique</title></head>
<body>
    <form id="csrf-salaire" method="POST"
          action="https://rh-interne.atlastech.local/employes/modifier_salaire.php">
        <input type="hidden" name="employe_id" value="15">
        <input type="hidden" name="salaire" value="50000.00">
        <!-- Augmentation du salaire de l'employé ID=15 à 50,000 MAD -->
    </form>
    
    <script>
        document.getElementById('csrf-salaire').submit();
    </script>
</body>
</html>
```

---

## Solution : Tokens CSRF (APRÈS)

### 15.4.5 Principe du Token CSRF

Un **token CSRF** est une valeur aléatoire et imprévisible générée par le serveur, associée à la session de l'utilisateur, et insérée dans les formulaires. Lors de la soumission, le serveur vérifie que le token reçu correspond à celui stocké en session.

**Flux de protection CSRF :**

```
1. Utilisateur demande une page avec formulaire
   ↓
2. Serveur génère un token CSRF aléatoire (ex: 64 caractères)
   ↓
3. Serveur stocke le token dans $_SESSION['csrf_token']
   ↓
4. Serveur insère le token dans le formulaire (champ caché)
   ↓
5. Utilisateur soumet le formulaire
   ↓
6. Serveur compare le token reçu avec celui en session
   ↓
7a. Si tokens correspondent → Requête légitime → Action autorisée
7b. Si tokens diffèrent → Attaque CSRF → Requête rejetée
```

**Pourquoi l'attaquant ne peut pas deviner le token ?**

- Token généré avec `random_bytes()` (cryptographiquement sûr)
- Longueur de 32 bytes (256 bits) = 2^256 possibilités
- Token unique par session
- Token imprévisible (pas basé sur le temps ou l'user_id)

### 15.4.6 Implémentation - Génération du Token

**Fichier `/var/www/html/crud-rh/includes/csrf.php` (bibliothèque CSRF) :**

```php
<?php
/**
 * Bibliothèque de protection CSRF
 * Génération et validation de tokens anti-CSRF
 */

class CSRF {
    
    /**
     * Génère un token CSRF sécurisé
     * @return string Token de 64 caractères hexadécimaux
     */
    public static function generateToken() {
        // Génération de 32 bytes aléatoires cryptographiquement sûrs
        $token = bin2hex(random_bytes(32));
        
        // Stockage dans la session
        $_SESSION['csrf_token'] = $token;
        $_SESSION['csrf_token_time'] = time();
        
        return $token;
    }
    
    /**
     * Récupère le token actuel (ou en génère un nouveau)
     * @return string Token CSRF
     */
    public static function getToken() {
        // Si le token n'existe pas ou a expiré (> 1 heure), en générer un nouveau
        if (!isset($_SESSION['csrf_token']) || 
            !isset($_SESSION['csrf_token_time']) ||
            (time() - $_SESSION['csrf_token_time']) > 3600) {
            return self::generateToken();
        }
        
        return $_SESSION['csrf_token'];
    }
    
    /**
     * Valide le token CSRF reçu
     * @param string $token Token à valider
     * @return bool True si valide, False sinon
     */
    public static function validateToken($token) {
        // Vérification de l'existence du token en session
        if (!isset($_SESSION['csrf_token'])) {
            return false;
        }
        
        // Vérification de l'expiration (1 heure)
        if (!isset($_SESSION['csrf_token_time']) ||
            (time() - $_SESSION['csrf_token_time']) > 3600) {
            return false;
        }
        
        // Comparaison sécurisée (protection contre timing attacks)
        return hash_equals($_SESSION['csrf_token'], $token);
    }
    
    /**
     * Génère un champ input hidden contenant le token CSRF
     * @return string HTML du champ input
     */
    public static function inputField() {
        $token = self::getToken();
        return '<input type="hidden" name="csrf_token" value="' . htmlspecialchars($token, ENT_QUOTES, 'UTF-8') . '">';
    }
    
    /**
     * Valide la requête CSRF ou termine le script
     * @throws Exception Si le token est invalide
     */
    public static function validateOrDie() {
        $token = $_POST['csrf_token'] ?? $_GET['csrf_token'] ?? '';
        
        if (!self::validateToken($token)) {
            // Log de la tentative d'attaque
            error_log("[CSRF Attack] IP: " . $_SERVER['REMOTE_ADDR'] . 
                      " | User: " . ($_SESSION['username'] ?? 'unknown') .
                      " | URI: " . $_SERVER['REQUEST_URI']);
            
            // Réponse HTTP 403
            http_response_code(403);
            die("Erreur de validation CSRF. Veuillez rafraîchir la page et réessayer.");
        }
    }
}
?>
```

### 15.4.7 Utilisation - Formulaire de Suppression Sécurisé

**Fichier `/var/www/html/crud-rh/employes/supprimer.php` (VERSION SÉCURISÉE) :**

```php
<?php
session_start();

// Vérification authentification
if (!isset($_SESSION['logged_in']) || $_SESSION['logged_in'] !== true) {
    header("Location: /login.php");
    exit;
}

// Vérification rôle
if (!in_array($_SESSION['role'], ['admin', 'rh'])) {
    http_response_code(403);
    die("Accès interdit");
}

require_once '../config/database.php';
require_once '../includes/csrf.php';

// Récupération de l'ID employé
$employe_id = $_GET['id'] ?? $_POST['employe_id'] ?? null;

// Validation de l'ID
if (!filter_var($employe_id, FILTER_VALIDATE_INT, ["options" => ["min_range" => 1]])) {
    http_response_code(400);
    die("ID employé invalide");
}

// Récupération des informations de l'employé
$sql = "SELECT id, prenom, nom FROM employes WHERE id = :id";
$stmt = $pdo->prepare($sql);
$stmt->execute([':id' => $employe_id]);
$employe = $stmt->fetch();

if (!$employe) {
    http_response_code(404);
    die("Employé introuvable");
}

// Traitement de la suppression (POST)
if ($_SERVER['REQUEST_METHOD'] === 'POST') {
    
    // SOLUTION : Validation du token CSRF
    CSRF::validateOrDie();
    
    try {
        // Transaction pour garantir l'intégrité
        $pdo->beginTransaction();
        
        // Suppression de l'employé
        $sql = "DELETE FROM employes WHERE id = :id";
        $stmt = $pdo->prepare($sql);
        $stmt->execute([':id' => $employe_id]);
        
        // Log d'audit
        $log_sql = "INSERT INTO audit_logs 
                    (user_id, action, entity_type, entity_id, old_values, created_at)
                    VALUES 
                    (:user_id, 'delete', 'employe', :entity_id, :values, NOW())";
        
        $log_stmt = $pdo->prepare($log_sql);
        $log_stmt->execute([
            ':user_id' => $_SESSION['user_id'],
            ':entity_id' => $employe_id,
            ':values' => json_encode($employe)
        ]);
        
        $pdo->commit();
        
        $_SESSION['success'] = "Employé {$employe['prenom']} {$employe['nom']} supprimé avec succès";
        header("Location: /employes/liste.php");
        exit;
        
    } catch (PDOException $e) {
        $pdo->rollBack();
        error_log("Erreur suppression : " . $e->getMessage());
        $_SESSION['error'] = "Erreur lors de la suppression";
        header("Location: /employes/liste.php");
        exit;
    }
}
?>

<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <title>Confirmation de suppression</title>
    <style>
        .warning-box {
            background-color: #fff3cd;
            border: 1px solid #ffc107;
            padding: 20px;
            margin: 20px;
            border-radius: 5px;
        }
        .btn-danger {
            background-color: #dc3545;
            color: white;
            padding: 10px 20px;
            border: none;
            cursor: pointer;
        }
        .btn-secondary {
            background-color: #6c757d;
            color: white;
            padding: 10px 20px;
            border: none;
            cursor: pointer;
            margin-left: 10px;
        }
    </style>
</head>
<body>
    <div class="warning-box">
        <h2>Confirmation de suppression</h2>
        <p><strong>Attention :</strong> Vous êtes sur le point de supprimer l'employé suivant :</p>
        
        <ul>
            <li><strong>ID :</strong> <?= htmlspecialchars($employe['id']) ?></li>
            <li><strong>Nom complet :</strong> <?= htmlspecialchars($employe['prenom'] . ' ' . $employe['nom']) ?></li>
        </ul>
        
        <p style="color: red;"><strong>Cette action est irréversible !</strong></p>
        
        <!-- SOLUTION : Formulaire avec token CSRF -->
        <form method="POST" action="/employes/supprimer.php">
            <input type="hidden" name="employe_id" value="<?= htmlspecialchars($employe_id) ?>">
            
            <!-- Insertion automatique du token CSRF -->
            <?= CSRF::inputField() ?>
            
            <button type="submit" class="btn-danger" onclick="return confirm('Êtes-vous absolument sûr ?');">
                Confirmer la suppression
            </button>
            
            <a href="/employes/liste.php">
                <button type="button" class="btn-secondary">Annuler</button>
            </a>
        </form>
    </div>
</body>
</html>
```

**Vérification du token dans le HTML généré :**

```bash
# Affichage du code source de la page
curl -b "PHPSESSID=abc123..." https://rh-interne.atlastech.local/employes/supprimer.php?id=5

# Résultat (extrait) :
<form method="POST" action="/employes/supprimer.php">
    <input type="hidden" name="employe_id" value="5">
    <input type="hidden" name="csrf_token" value="8f3d7a2b9c1e4f6a5d8b7c9e2f1a4b6c3d5e7f9a1b3c5d7e9f2a4b6c8d1e3f5a7b">
    <button type="submit" class="btn-danger">Confirmer la suppression</button>
</form>

# Le token est unique et change à chaque chargement de page
```

### 15.4.8 Modification Sécurisée (Formulaire d'Édition)

**Fichier `/var/www/html/crud-rh/employes/modifier.php` (VERSION SÉCURISÉE) :**

```php
<?php
session_start();
require_once '../config/database.php';
require_once '../includes/csrf.php';

// Vérifications d'authentification et de rôle
// ... (code similaire à supprimer.php)

$employe_id = $_GET['id'] ?? $_POST['employe_id'] ?? null;

if ($_SERVER['REQUEST_METHOD'] === 'POST') {
    
    // VALIDATION CSRF
    CSRF::validateOrDie();
    
    // Récupération des données du formulaire
    $prenom = trim($_POST['prenom'] ?? '');
    $nom = trim($_POST['nom'] ?? '');
    $email = trim($_POST['email'] ?? '');
    $salaire = $_POST['salaire'] ?? null;
    
    // Validations
    // ... (voir section 15.8)
    
    try {
        $sql = "UPDATE employes 
                SET prenom = :prenom,
                    nom = :nom,
                    email = :email,
                    salaire_mensuel = :salaire,
                    updated_at = NOW(),
                    updated_by = :updated_by
                WHERE id = :id";
        
        $stmt = $pdo->prepare($sql);
        $stmt->execute([
            ':prenom' => $prenom,
            ':nom' => $nom,
            ':email' => $email,
            ':salaire' => $salaire,
            ':updated_by' => $_SESSION['user_id'],
            ':id' => $employe_id
        ]);
        
        $_SESSION['success'] = "Employé modifié avec succès";
        header("Location: /employes/voir_detail.php?id=" . $employe_id);
        exit;
        
    } catch (PDOException $e) {
        error_log("Erreur modification : " . $e->getMessage());
        $_SESSION['error'] = "Erreur lors de la modification";
    }
}

// Récupération des données existantes
$sql = "SELECT * FROM employes WHERE id = :id";
$stmt = $pdo->prepare($sql);
$stmt->execute([':id' => $employe_id]);
$employe = $stmt->fetch();
?>

<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <title>Modifier l'employé</title>
</head>
<body>
    <h1>Modifier l'employé</h1>
    
    <!-- FORMULAIRE SÉCURISÉ AVEC TOKEN CSRF -->
    <form method="POST" action="/employes/modifier.php">
        <input type="hidden" name="employe_id" value="<?= htmlspecialchars($employe['id']) ?>">
        
        <!-- Token CSRF -->
        <?= CSRF::inputField() ?>
        
        <div>
            <label for="prenom">Prénom :</label>
            <input type="text" id="prenom" name="prenom" 
                   value="<?= htmlspecialchars($employe['prenom']) ?>" required>
        </div>
        
        <div>
            <label for="nom">Nom :</label>
            <input type="text" id="nom" name="nom" 
                   value="<?= htmlspecialchars($employe['nom']) ?>" required>
        </div>
        
        <div>
            <label for="email">Email :</label>
            <input type="email" id="email" name="email" 
                   value="<?= htmlspecialchars($employe['email']) ?>" required>
        </div>
        
        <?php if (in_array($_SESSION['role'], ['admin', 'rh'])): ?>
        <div>
            <label for="salaire">Salaire mensuel (MAD) :</label>
            <input type="number" id="salaire" name="salaire" step="0.01"
                   value="<?= htmlspecialchars($employe['salaire_mensuel']) ?>" required>
        </div>
        <?php endif; ?>
        
        <button type="submit">Enregistrer les modifications</button>
        <a href="/employes/liste.php"><button type="button">Annuler</button></a>
    </form>
</body>
</html>
```

---

## Protection Additionnelle : SameSite Cookie

### 15.4.9 Attribut SameSite des Cookies

L'attribut `SameSite` des cookies offre une **protection supplémentaire contre CSRF** en contrôlant quand les cookies sont envoyés dans les requêtes cross-origin.

**Valeurs possibles :**

| Valeur | Comportement | Protection CSRF |
|--------|--------------|-----------------|
| `Strict` | Cookie jamais envoyé dans les requêtes cross-site | Maximum (peut casser certaines fonctionnalités) |
| `Lax` | Cookie envoyé uniquement pour les requêtes GET cross-site | Bonne (défaut recommandé) |
| `None` | Cookie toujours envoyé (nécessite Secure) | Aucune |

**Configuration PHP :**

```php
<?php
// Fichier de configuration de session
// /var/www/html/crud-rh/config/session.php

// Configuration de la session avec SameSite
session_set_cookie_params([
    'lifetime' => 3600,              // 1 heure
    'path' => '/',
    'domain' => 'rh-interne.atlastech.local',
    'secure' => true,                // HTTPS uniquement
    'httponly' => true,              // Pas accessible en JavaScript
    'samesite' => 'Strict'           // Protection CSRF
]);

session_start();
?>
```

**Vérification de la configuration :**

```bash
# Inspection des cookies avec curl
curl -I -c cookies.txt https://rh-interne.atlastech.local/login.php

# Contenu du fichier cookies.txt :
# Netscape HTTP Cookie File
rh-interne.atlastech.local  FALSE   /   TRUE    1704114000  PHPSESSID  abc123...   SameSite=Strict

# Attributs présents :
# - Secure (HTTPS uniquement)
# - HttpOnly (protection XSS)
# - SameSite=Strict (protection CSRF)
```

**Test de SameSite :**

```html
<!-- Page malveillante sur evil.com -->
<form id="test-csrf" method="POST"
      action="https://rh-interne.atlastech.local/employes/supprimer.php">
    <input type="hidden" name="employe_id" value="5">
    <input type="hidden" name="csrf_token" value="fake-token">
</form>

<script>
    document.getElementById('test-csrf').submit();
</script>
```

**Résultat avec SameSite=Strict :**

```
1. Formulaire se soumet depuis evil.com
2. Navigateur détecte une requête cross-site (evil.com → rh-interne.atlastech.local)
3. Navigateur NE PAS envoyer le cookie PHPSESSID (grâce à SameSite=Strict)
4. Serveur RH reçoit la requête SANS cookie de session
5. Serveur rejette la requête (utilisateur non authentifié)
6. Attaque CSRF échoue MÊME si le token CSRF était deviné
```

### 15.4.10 Double Submit Cookie Pattern

Une technique alternative au token en session est le **Double Submit Cookie** : le token est stocké à la fois dans un cookie ET dans le formulaire.

**Implémentation :**

```php
<?php
/**
 * Classe CSRF avec Double Submit Cookie
 */
class CSRFCookie {
    
    public static function generateToken() {
        $token = bin2hex(random_bytes(32));
        
        // Stockage dans un cookie dédié (pas dans la session)
        setcookie(
            'csrf_token_cookie',
            $token,
            [
                'expires' => time() + 3600,
                'path' => '/',
                'domain' => 'rh-interne.atlastech.local',
                'secure' => true,
                'httponly' => true,  // Protection XSS
                'samesite' => 'Strict'
            ]
        );
        
        return $token;
    }
    
    public static function getToken() {
        if (!isset($_COOKIE['csrf_token_cookie'])) {
            return self::generateToken();
        }
        return $_COOKIE['csrf_token_cookie'];
    }
    
    public static function validateToken($token) {
        // Vérifier que le token du formulaire correspond au token du cookie
        if (!isset($_COOKIE['csrf_token_cookie'])) {
            return false;
        }
        
        return hash_equals($_COOKIE['csrf_token_cookie'], $token);
    }
}
?>
```

**Avantage :** Fonctionne avec des applications stateless (sans session)  
**Inconvénient :** Légèrement moins sécurisé que le token en session

---

## Vérification de l'Origine (Defense in Depth)

### 15.4.11 Validation des Headers Origin et Referer

En complément des tokens CSRF, on peut vérifier que la requête provient du bon domaine.

**Fichier `/var/www/html/crud-rh/includes/origin-validation.php` :**

```php
<?php
/**
 * Validation de l'origine des requêtes
 */
class OriginValidator {
    
    private static $allowed_origins = [
        'https://rh-interne.atlastech.local'
    ];
    
    /**
     * Valide que la requête provient d'une origine autorisée
     * @return bool True si valide, False sinon
     */
    public static function validate() {
        // Vérification du header Origin (prioritaire)
        if (isset($_SERVER['HTTP_ORIGIN'])) {
            return in_array($_SERVER['HTTP_ORIGIN'], self::$allowed_origins);
        }
        
        // Vérification du header Referer (fallback)
        if (isset($_SERVER['HTTP_REFERER'])) {
            $referer_host = parse_url($_SERVER['HTTP_REFERER'], PHP_URL_HOST);
            $allowed_host = parse_url(self::$allowed_origins[0], PHP_URL_HOST);
            
            return $referer_host === $allowed_host;
        }
        
        // Si aucun header présent, rejeter par sécurité
        return false;
    }
    
    /**
     * Valide l'origine ou termine le script
     */
    public static function validateOrDie() {
        if (!self::validate()) {
            error_log("[Origin Validation Failed] IP: " . $_SERVER['REMOTE_ADDR'] .
                      " | Origin: " . ($_SERVER['HTTP_ORIGIN'] ?? 'N/A') .
                      " | Referer: " . ($_SERVER['HTTP_REFERER'] ?? 'N/A'));
            
            http_response_code(403);
            die("Origine de la requête non autorisée");
        }
    }
}
?>
```

**Utilisation combinée (Token CSRF + Origin) :**

```php
<?php
require_once '../includes/csrf.php';
require_once '../includes/origin-validation.php';

if ($_SERVER['REQUEST_METHOD'] === 'POST') {
    // DOUBLE VÉRIFICATION (Defense in Depth)
    OriginValidator::validateOrDie();  // Vérifier l'origine
    CSRF::validateOrDie();             // Vérifier le token CSRF
    
    // Si les deux validations passent, traiter la requête
    // ...
}
?>
```

---

## Gestion des Formulaires AJAX

### 15.4.12 Protection CSRF pour les Requêtes AJAX

Les requêtes AJAX doivent également inclure le token CSRF.

**Fichier JavaScript `/var/www/html/crud-rh/js/ajax-csrf.js` :**

```javascript
/**
 * Configuration globale AJAX avec token CSRF
 */

// Récupération du token CSRF depuis un meta tag
function getCsrfToken() {
    const metaTag = document.querySelector('meta[name="csrf-token"]');
    return metaTag ? metaTag.getAttribute('content') : '';
}

// Configuration Fetch API avec token CSRF
async function secureFetch(url, options = {}) {
    // Ajout du token CSRF dans les headers
    const defaultOptions = {
        headers: {
            'X-CSRF-Token': getCsrfToken(),
            'Content-Type': 'application/json'
        },
        credentials: 'same-origin' // Inclure les cookies
    };
    
    // Fusion des options
    const mergedOptions = {
        ...defaultOptions,
        ...options,
        headers: {
            ...defaultOptions.headers,
            ...(options.headers || {})
        }
    };
    
    return fetch(url, mergedOptions);
}

// Exemple d'utilisation : Suppression d'un employé via AJAX
async function supprimerEmploye(employeId) {
    try {
        const response = await secureFetch('/api/employes/supprimer', {
            method: 'POST',
            body: JSON.stringify({ employe_id: employeId })
        });
        
        if (!response.ok) {
            throw new Error('Erreur lors de la suppression');
        }
        
        const data = await response.json();
        console.log('Employé supprimé:', data);
        
    } catch (error) {
        console.error('Erreur:', error);
    }
}
```

**Backend PHP pour requêtes AJAX :**

```php
<?php
session_start();
require_once '../includes/csrf.php';

// Récupération du token depuis le header
$csrf_token = $_SERVER['HTTP_X_CSRF_TOKEN'] ?? '';

// Validation
if (!CSRF::validateToken($csrf_token)) {
    http_response_code(403);
    echo json_encode(['error' => 'Invalid CSRF token']);
    exit;
}

// Traitement de la requête
$input = json_decode(file_get_contents('php://input'), true);
$employe_id = $input['employe_id'] ?? null;

// ... logique de suppression ...

echo json_encode(['success' => true, 'message' => 'Employé supprimé']);
?>
```

**Insertion du token dans le HTML :**

```php
<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="csrf-token" content="<?= CSRF::getToken() ?>">
    <title>Application RH</title>
</head>
<body>
    <!-- Contenu de la page -->
    <script src="/js/ajax-csrf.js"></script>
</body>
</html>
```

---

## Tests et Validation

### 15.4.13 Test de Vulnérabilité CSRF

**Outil : OWASP ZAP (Zed Attack Proxy)**

```bash
# Lancement de ZAP
zaproxy

# Configuration du test CSRF :
1. Scanner l'application (Spider + Active Scan)
2. Analyser les formulaires détectés
3. Tester la suppression/modification du token CSRF
4. Générer un rapport

# Résultat AVANT protection :
- High Risk: CSRF vulnerability detected
- URL: /employes/supprimer.php
- Evidence: No CSRF token found

# Résultat APRÈS protection :
- No CSRF vulnerabilities detected
- Information: CSRF tokens properly implemented
```

**Test manuel avec Burp Suite :**

```
1. Intercepter une requête POST légitime avec Burp Proxy
2. Envoyer vers Repeater
3. Modifier ou supprimer le paramètre csrf_token
4. Renvoyer la requête

Résultat attendu (version sécurisée) :
HTTP/1.1 403 Forbidden
Erreur de validation CSRF. Veuillez rafraîchir la page et réessayer.
```

### 15.4.14 Checklist de Protection CSRF

```bash
#!/bin/bash
# Script de vérification CSRF

echo "=== Vérification Protection CSRF ==="

# 1. Vérifier la présence de tokens dans les formulaires
echo "[1] Recherche de formulaires avec tokens CSRF..."
grep -r "csrf_token" /var/www/html/crud-rh/*.php | wc -l

# 2. Vérifier l'utilisation de CSRF::validateToken()
echo "[2] Vérification des validations CSRF..."
grep -r "CSRF::validate" /var/www/html/crud-rh/*.php | wc -l

# 3. Vérifier la configuration SameSite des cookies
echo "[3] Vérification SameSite cookie..."
php -r "echo ini_get('session.cookie_samesite');"

# Résultat attendu : Strict ou Lax

# 4. Test d'une requête sans token (doit échouer)
echo "[4] Test de requête POST sans token CSRF..."
RESPONSE=$(curl -s -o /dev/null -w "%{http_code}" \
    -X POST https://rh-interne.atlastech.local/employes/supprimer.php \
    -d "employe_id=999" \
    -b "PHPSESSID=test_session")

if [ "$RESPONSE" -eq 403 ]; then
    echo "✓ Protection CSRF active (403 Forbidden)"
else
    echo "✗ VULNÉRABILITÉ CSRF DÉTECTÉE (Code: $RESPONSE)"
fi

echo "=== Vérification terminée ==="
```

---

## Résumé et Bonnes Pratiques

### 15.4.15 Tableau Comparatif

| Aspect | AVANT (Vulnérable) | APRÈS (Sécurisé) |
|--------|-------------------|------------------|
| **Formulaire** | Aucun token | Token CSRF unique par session |
| **Validation** | Accepte toute requête authentifiée | Vérifie token + origine |
| **Cookie** | SameSite non défini | SameSite=Strict |
| **AJAX** | Aucune protection | Header X-CSRF-Token |
| **Expiration** | Token permanent | Expire après 1 heure |
| **Logging** | Aucun log d'attaque | Log des tentatives CSRF |

### 15.4.16 Règles d'Or de la Protection CSRF

1. **Générer un token unique** pour chaque session utilisateur
2. **Inclure le token** dans tous les formulaires de modification de données
3. **Valider le token** côté serveur avant toute action destructrice
4. **Utiliser SameSite=Strict** pour les cookies de session
5. **Vérifier l'origine** des requêtes (header Origin/Referer)
6. **Expirer les tokens** après un certain temps (1 heure recommandée)
7. **Logger les tentatives** d'attaque CSRF pour analyse

---

## Références Normatives

**OWASP :**
- OWASP Top 10 2021 - A01:2021 Broken Access Control
- OWASP CSRF Prevention Cheat Sheet : https://cheatsheetseries.owasp.org/cheatsheets/Cross-Site_Request_Forgery_Prevention_Cheat_Sheet.html

**CWE :**
- CWE-352: Cross-Site Request Forgery (CSRF)

**RFC :**
- RFC 6265 (HTTP State Management Mechanism - Cookies)
- RFC 6749 (OAuth 2.0) - Section 10.12 sur CSRF

**ANSSI :**
- Recommandations de sécurité relatives aux applications web

---

:::tip Prochaine Section
La section **15.5 Mass Assignment Protection** abordera la protection contre la modification non autorisée de champs sensibles via l'injection de paramètres.
:::