---
id: mass-assignment-protection
title: Protection Mass Assignment
sidebar_label: "15.5 Mass Assignment Protection"
sidebar_position: 5
---

# 15.5 Protection Mass Assignment

## Introduction au Mass Assignment

### Qu'est-ce que le Mass Assignment ?

Le Mass Assignment (affectation en masse) est une vulnérabilité qui se produit lorsqu'une application accepte aveuglément tous les paramètres envoyés par l'utilisateur et les assigne directement aux propriétés d'un objet ou aux colonnes d'une base de données, **sans vérification des champs autorisés**.

**Analogie simple :**

Imaginez un formulaire d'inscription où vous remplissez votre nom, prénom et email. Mais si le système accepte TOUS les champs envoyés sans filtre, un utilisateur malveillant pourrait ajouter un champ caché `is_admin=1` et se donner des privilèges administrateur.

**Impact d'une attaque Mass Assignment :**

- Élévation de privilèges (devenir administrateur)
- Modification de champs sensibles (salaire, rôle, statut)
- Contournement de la logique métier
- Injection de données malveillantes
- Corruption de l'intégrité des données

:::danger Classification
**OWASP Top 10 2021 :** A04:2021 – Insecure Design
**CWE-915 :** Improperly Controlled Modification of Dynamically-Determined Object Attributes
**CVSS Score :** 7.5 (HIGH)
:::

---

## État Actuel : Code Vulnérable (AVANT)

### 15.5.1 Ajout d'Employé Vulnérable

**Fichier `/var/www/html/crud-rh/employes/ajouter.php` (VERSION VULNÉRABLE) :**

```php
<?php
session_start();
require_once '../config/database.php';

if ($_SERVER['REQUEST_METHOD'] === 'POST') {
    
    // VULNÉRABILITÉ : Affectation en masse de tous les champs POST
    $fields = array_keys($_POST);
    $values = array_values($_POST);
    
    // Construction dynamique de la requête SQL
    $placeholders = implode(',', array_fill(0, count($fields), '?'));
    $field_names = implode(',', $fields);
    
    $sql = "INSERT INTO employes ($field_names) VALUES ($placeholders)";
    $stmt = $pdo->prepare($sql);
    $stmt->execute($values);
    
    echo "Employé ajouté avec succès";
}
?>

<form method="POST">
    <input type="text" name="prenom" placeholder="Prénom" required>
    <input type="text" name="nom" placeholder="Nom" required>
    <input type="email" name="email" placeholder="Email" required>
    <button type="submit">Ajouter</button>
</form>
```

**Exploitation de la vulnérabilité :**

```bash
# Requête POST normale
curl -X POST https://rh-interne.atlastech.local/employes/ajouter.php \
  -d "prenom=Ahmed&nom=Alami&email=ahmed@test.com"

# Résultat : Employé créé normalement


# Requête POST malveillante (Mass Assignment Attack)
curl -X POST https://rh-interne.atlastech.local/employes/ajouter.php \
  -d "prenom=Hacker&nom=Evil&email=hacker@evil.com&salaire_mensuel=999999&is_admin=1&statut=actif"

# Résultat : Employé créé avec un salaire de 999,999 MAD et potentiellement des privilèges admin !

# Requête SQL générée :
INSERT INTO employes (prenom, nom, email, salaire_mensuel, is_admin, statut) 
VALUES ('Hacker', 'Evil', 'hacker@evil.com', 999999, 1, 'actif')
```

**Vérification dans la base de données :**

```sql
SELECT * FROM employes WHERE email = 'hacker@evil.com';

-- Résultat :
+----+---------+-------+-------------------+------------------+----------+--------+
| id | prenom  | nom   | email             | salaire_mensuel  | is_admin | statut |
+----+---------+-------+-------------------+------------------+----------+--------+
| 99 | Hacker  | Evil  | hacker@evil.com   | 999999.00        | 1        | actif  |
+----+---------+-------+-------------------+------------------+----------+--------+

-- L'attaquant a modifié des champs qu'il ne devrait pas pouvoir toucher !
```

### 15.5.2 Modification Vulnérable

**Fichier `/var/www/html/crud-rh/employes/modifier.php` (VERSION VULNÉRABLE) :**

```php
<?php
if ($_SERVER['REQUEST_METHOD'] === 'POST') {
    $employe_id = $_POST['id'];
    
    // VULNÉRABILITÉ : Mise à jour en masse
    unset($_POST['id']); // Retirer l'ID des champs à modifier
    
    $set_clause = [];
    foreach ($_POST as $field => $value) {
        $set_clause[] = "$field = :$field";
    }
    
    $sql = "UPDATE employes SET " . implode(', ', $set_clause) . " WHERE id = :id";
    $stmt = $pdo->prepare($sql);
    
    $_POST['id'] = $employe_id; // Remettre l'ID pour l'exécution
    $stmt->execute($_POST);
}
?>
```

**Exploitation - Élévation de privilège :**

```bash
# Modification légitime
curl -X POST https://rh-interne.atlastech.local/employes/modifier.php \
  -d "id=15&prenom=Mohammed&nom=Benali"

# Modification malveillante (attaquant modifie son propre profil)
curl -X POST https://rh-interne.atlastech.local/employes/modifier.php \
  -d "id=15&prenom=Mohammed&nom=Benali&role=admin&salaire_mensuel=50000"

# Requête SQL générée :
UPDATE employes SET prenom = 'Mohammed', nom = 'Benali', role = 'admin', salaire_mensuel = 50000 
WHERE id = 15

-- L'employé ID=15 s'auto-promote en admin et augmente son salaire !
```

---

## Solution : Whitelist des Champs (APRÈS)

### 15.5.3 Principe de la Whitelist

Au lieu d'accepter tous les champs envoyés, on définit explicitement la **liste blanche (whitelist)** des champs autorisés pour chaque opération.

**Règle d'or :** Ne jamais faire confiance aux données utilisateur, TOUJOURS filtrer.

### 15.5.4 Ajout Sécurisé avec Whitelist

**Fichier `/var/www/html/crud-rh/employes/ajouter.php` (VERSION SÉCURISÉE) :**

```php
<?php
session_start();
require_once '../config/database.php';
require_once '../includes/csrf.php';

if ($_SERVER['REQUEST_METHOD'] === 'POST') {
    
    // VALIDATION CSRF
    CSRF::validateOrDie();
    
    // SOLUTION 1 : WHITELIST des champs autorisés
    $allowed_fields = [
        'cin',
        'prenom',
        'nom',
        'date_naissance',
        'email',
        'telephone',
        'adresse',
        'departement_id',
        'poste_id'
    ];
    
    // Extraction UNIQUEMENT des champs autorisés
    $data = [];
    foreach ($allowed_fields as $field) {
        if (isset($_POST[$field])) {
            $data[$field] = trim($_POST[$field]);
        }
    }
    
    // Vérification des champs obligatoires
    $required_fields = ['cin', 'prenom', 'nom', 'email'];
    foreach ($required_fields as $field) {
        if (empty($data[$field])) {
            die("Le champ $field est obligatoire");
        }
    }
    
    // Validations spécifiques
    if (!filter_var($data['email'], FILTER_VALIDATE_EMAIL)) {
        die("Email invalide");
    }
    
    if (!preg_match('/^[A-Z]{1,2}[0-9]{6}$/', $data['cin'])) {
        die("CIN invalide");
    }
    
    try {
        // CHAMPS SENSIBLES DÉFINIS PAR LE SYSTÈME (pas par l'utilisateur)
        $system_fields = [
            'date_embauche' => date('Y-m-d'),
            'salaire_mensuel' => 5000.00,  // Salaire de base défini par le système
            'type_contrat' => 'CDD',       // Valeur par défaut
            'statut' => 'en_attente',      // Statut initial
            'created_by' => $_SESSION['user_id'],
            'created_at' => date('Y-m-d H:i:s')
        ];
        
        // Fusion des données utilisateur (filtrées) et des champs système
        $final_data = array_merge($data, $system_fields);
        
        // Construction de la requête SQL avec les champs connus
        $fields = array_keys($final_data);
        $placeholders = ':' . implode(', :', $fields);
        $field_names = implode(', ', $fields);
        
        $sql = "INSERT INTO employes ($field_names) VALUES ($placeholders)";
        $stmt = $pdo->prepare($sql);
        
        // Binding des valeurs
        foreach ($final_data as $key => $value) {
            $stmt->bindValue(":$key", $value);
        }
        
        $stmt->execute();
        
        $_SESSION['success'] = "Employé ajouté avec succès";
        header("Location: /employes/liste.php");
        exit;
        
    } catch (PDOException $e) {
        error_log("Erreur ajout employé : " . $e->getMessage());
        die("Erreur lors de l'ajout");
    }
}
?>

<form method="POST">
    <?= CSRF::inputField() ?>
    
    <input type="text" name="cin" placeholder="CIN" required>
    <input type="text" name="prenom" placeholder="Prénom" required>
    <input type="text" name="nom" placeholder="Nom" required>
    <input type="email" name="email" placeholder="Email" required>
    <input type="tel" name="telephone" placeholder="Téléphone">
    
    <select name="departement_id" required>
        <option value="">-- Département --</option>
        <!-- Options chargées depuis la BDD -->
    </select>
    
    <select name="poste_id" required>
        <option value="">-- Poste --</option>
        <!-- Options chargées depuis la BDD -->
    </select>
    
    <button type="submit">Ajouter l'employé</button>
</form>
```

**Test de sécurité :**

```bash
# Tentative d'injection de champs sensibles (doit échouer)
curl -X POST https://rh-interne.atlastech.local/employes/ajouter.php \
  -d "prenom=Test&nom=User&email=test@test.com&salaire_mensuel=999999&is_admin=1"

# Requête SQL réellement exécutée :
INSERT INTO employes (cin, prenom, nom, email, date_embauche, salaire_mensuel, type_contrat, statut, created_by) 
VALUES ('', 'Test', 'User', 'test@test.com', '2024-01-15', 5000.00, 'CDD', 'en_attente', 3)

# Les champs salaire_mensuel=999999 et is_admin=1 sont IGNORÉS
# Seul le salaire système (5000.00) est utilisé
```

### 15.5.5 Modification Sécurisée avec Permissions

**Fichier `/var/www/html/crud-rh/employes/modifier.php` (VERSION SÉCURISÉE) :**

```php
<?php
session_start();
require_once '../config/database.php';
require_once '../includes/csrf.php';

if ($_SERVER['REQUEST_METHOD'] === 'POST') {
    
    CSRF::validateOrDie();
    
    $employe_id = $_POST['id'] ?? null;
    
    if (!filter_var($employe_id, FILTER_VALIDATE_INT)) {
        die("ID invalide");
    }
    
    // SOLUTION 2 : Whitelist basée sur les permissions de l'utilisateur
    
    // Champs modifiables par tous les utilisateurs RH
    $basic_fields = [
        'prenom',
        'nom',
        'telephone',
        'adresse',
        'email'
    ];
    
    // Champs modifiables UNIQUEMENT par les admins
    $admin_only_fields = [
        'salaire_mensuel',
        'type_contrat',
        'statut',
        'departement_id',
        'poste_id'
    ];
    
    // Déterminer les champs autorisés selon le rôle
    $allowed_fields = $basic_fields;
    
    if ($_SESSION['role'] === 'admin') {
        $allowed_fields = array_merge($allowed_fields, $admin_only_fields);
    }
    
    // Extraction des champs autorisés
    $data = [];
    foreach ($allowed_fields as $field) {
        if (isset($_POST[$field])) {
            $data[$field] = trim($_POST[$field]);
        }
    }
    
    // Si aucune donnée à modifier
    if (empty($data)) {
        die("Aucune modification");
    }
    
    try {
        // Construction de la clause SET dynamique (mais sécurisée)
        $set_parts = [];
        foreach ($data as $field => $value) {
            $set_parts[] = "$field = :$field";
        }
        
        $sql = "UPDATE employes SET " . implode(', ', $set_parts) . ", 
                updated_at = NOW(), 
                updated_by = :updated_by 
                WHERE id = :id";
        
        $stmt = $pdo->prepare($sql);
        
        // Binding des valeurs
        foreach ($data as $key => $value) {
            $stmt->bindValue(":$key", $value);
        }
        
        $stmt->bindValue(':updated_by', $_SESSION['user_id'], PDO::PARAM_INT);
        $stmt->bindValue(':id', $employe_id, PDO::PARAM_INT);
        
        $stmt->execute();
        
        // Log d'audit
        $log_sql = "INSERT INTO audit_logs (user_id, action, entity_type, entity_id, new_values)
                    VALUES (:user_id, 'update', 'employe', :entity_id, :values)";
        $log_stmt = $pdo->prepare($log_sql);
        $log_stmt->execute([
            ':user_id' => $_SESSION['user_id'],
            ':entity_id' => $employe_id,
            ':values' => json_encode($data)
        ]);
        
        $_SESSION['success'] = "Employé modifié avec succès";
        header("Location: /employes/voir_detail.php?id=" . $employe_id);
        exit;
        
    } catch (PDOException $e) {
        error_log("Erreur modification : " . $e->getMessage());
        die("Erreur lors de la modification");
    }
}
?>
```

**Test avec utilisateur non-admin :**

```bash
# Utilisateur RH normal tente de modifier le salaire (doit échouer)
curl -X POST https://rh-interne.atlastech.local/employes/modifier.php \
  -b "PHPSESSID=session_rh_user" \
  -d "id=15&prenom=Ahmed&salaire_mensuel=50000"

# Requête SQL générée :
UPDATE employes SET prenom = 'Ahmed', updated_at = NOW(), updated_by = 5 
WHERE id = 15

# Le champ salaire_mensuel est IGNORÉ car l'utilisateur n'est pas admin
```

---

## Approche Orientée Objet (ORM-like)

### 15.5.6 Classe Model avec Guarded Fields

Pour une approche plus structurée, on peut créer une classe Model avec des champs protégés.

**Fichier `/var/www/html/crud-rh/models/Employe.php` :**

```php
<?php
/**
 * Model Employé avec protection Mass Assignment
 */
class Employe {
    
    private $pdo;
    
    // CHAMPS FILLABLE (autorisés pour affectation en masse)
    protected $fillable = [
        'cin',
        'prenom',
        'nom',
        'date_naissance',
        'email',
        'telephone',
        'adresse',
        'departement_id',
        'poste_id'
    ];
    
    // CHAMPS GUARDED (protégés contre l'affectation en masse)
    protected $guarded = [
        'id',
        'salaire_mensuel',
        'type_contrat',
        'statut',
        'is_admin',
        'created_at',
        'updated_at',
        'created_by',
        'updated_by'
    ];
    
    public function __construct($pdo) {
        $this->pdo = $pdo;
    }
    
    /**
     * Crée un employé avec protection Mass Assignment
     * @param array $data Données fournies par l'utilisateur
     * @param array $system_data Données système (salaire, statut, etc.)
     * @return int ID de l'employé créé
     */
    public function create(array $data, array $system_data = []) {
        // Filtrer uniquement les champs fillable
        $filtered_data = $this->filterFillable($data);
        
        // Valider les données
        $this->validate($filtered_data);
        
        // Fusionner avec les données système
        $final_data = array_merge($filtered_data, $system_data);
        
        // Insertion en base
        $fields = array_keys($final_data);
        $placeholders = ':' . implode(', :', $fields);
        
        $sql = "INSERT INTO employes (" . implode(', ', $fields) . ") 
                VALUES ($placeholders)";
        
        $stmt = $this->pdo->prepare($sql);
        
        foreach ($final_data as $key => $value) {
            $stmt->bindValue(":$key", $value);
        }
        
        $stmt->execute();
        
        return $this->pdo->lastInsertId();
    }
    
    /**
     * Filtre les champs selon la whitelist fillable
     * @param array $data Données brutes
     * @return array Données filtrées
     */
    private function filterFillable(array $data) {
        $filtered = [];
        
        foreach ($this->fillable as $field) {
            if (isset($data[$field])) {
                $filtered[$field] = $data[$field];
            }
        }
        
        return $filtered;
    }
    
    /**
     * Validation des données
     * @param array $data Données à valider
     * @throws Exception Si validation échoue
     */
    private function validate(array $data) {
        // CIN obligatoire
        if (empty($data['cin'])) {
            throw new Exception("Le CIN est obligatoire");
        }
        
        // Format CIN
        if (!preg_match('/^[A-Z]{1,2}[0-9]{6}$/', $data['cin'])) {
            throw new Exception("Format CIN invalide");
        }
        
        // Email obligatoire et valide
        if (empty($data['email']) || !filter_var($data['email'], FILTER_VALIDATE_EMAIL)) {
            throw new Exception("Email invalide");
        }
        
        // Téléphone marocain
        if (isset($data['telephone']) && !preg_match('/^(\+212|0)[67][0-9]{8}$/', $data['telephone'])) {
            throw new Exception("Numéro de téléphone marocain invalide");
        }
    }
    
    /**
     * Met à jour un employé avec protection Mass Assignment
     * @param int $id ID de l'employé
     * @param array $data Données à mettre à jour
     * @param string $user_role Rôle de l'utilisateur (pour permissions)
     * @return bool True si succès
     */
    public function update($id, array $data, $user_role) {
        // Filtrer selon le rôle
        if ($user_role === 'admin') {
            // Admin peut modifier tous les champs fillable + certains guarded
            $allowed = array_merge($this->fillable, ['salaire_mensuel', 'type_contrat', 'statut']);
        } else {
            // Utilisateur normal : uniquement fillable
            $allowed = $this->fillable;
        }
        
        // Filtrer les données
        $filtered = [];
        foreach ($allowed as $field) {
            if (isset($data[$field])) {
                $filtered[$field] = $data[$field];
            }
        }
        
        if (empty($filtered)) {
            throw new Exception("Aucune donnée à modifier");
        }
        
        // Construction de la requête
        $set_parts = [];
        foreach ($filtered as $field => $value) {
            $set_parts[] = "$field = :$field";
        }
        
        $sql = "UPDATE employes SET " . implode(', ', $set_parts) . " WHERE id = :id";
        $stmt = $this->pdo->prepare($sql);
        
        foreach ($filtered as $key => $value) {
            $stmt->bindValue(":$key", $value);
        }
        
        $stmt->bindValue(':id', $id, PDO::PARAM_INT);
        
        return $stmt->execute();
    }
}
?>
```

**Utilisation du Model :**

```php
<?php
require_once '../models/Employe.php';

$employeModel = new Employe($pdo);

// Création d'un employé
try {
    $user_data = $_POST; // Peut contenir des champs malveillants
    
    $system_data = [
        'salaire_mensuel' => 5000.00,
        'type_contrat' => 'CDD',
        'statut' => 'en_attente',
        'created_by' => $_SESSION['user_id'],
        'created_at' => date('Y-m-d H:i:s')
    ];
    
    $new_id = $employeModel->create($user_data, $system_data);
    
    echo "Employé créé avec l'ID : $new_id";
    
} catch (Exception $e) {
    echo "Erreur : " . $e->getMessage();
}

// Modification d'un employé
try {
    $employe_id = 15;
    $user_data = $_POST;
    $user_role = $_SESSION['role'];
    
    $employeModel->update($employe_id, $user_data, $user_role);
    
    echo "Employé modifié avec succès";
    
} catch (Exception $e) {
    echo "Erreur : " . $e->getMessage();
}
?>
```

---

## Validation Stricte des Types

### 15.5.7 Typage Fort avec filter_var()

En plus de la whitelist, il faut valider le type de chaque champ.

```php
<?php
/**
 * Validation stricte des types de données
 */
function validateEmployeeData(array $data) {
    $errors = [];
    
    // CIN : Chaîne alphanumérique
    if (isset($data['cin'])) {
        if (!preg_match('/^[A-Z]{1,2}[0-9]{6}$/', $data['cin'])) {
            $errors[] = "CIN invalide (format attendu : A123456)";
        }
    }
    
    // Email : Validation RFC
    if (isset($data['email'])) {
        if (!filter_var($data['email'], FILTER_VALIDATE_EMAIL)) {
            $errors[] = "Adresse email invalide";
        }
    }
    
    // Téléphone : Format marocain
    if (isset($data['telephone'])) {
        if (!preg_match('/^(\+212|0)[67][0-9]{8}$/', $data['telephone'])) {
            $errors[] = "Numéro de téléphone invalide (format : +212XXXXXXXXX ou 0XXXXXXXXX)";
        }
    }
    
    // Département ID : Entier positif
    if (isset($data['departement_id'])) {
        if (!filter_var($data['departement_id'], FILTER_VALIDATE_INT, ['options' => ['min_range' => 1]])) {
            $errors[] = "ID département invalide";
        }
    }
    
    // Poste ID : Entier positif
    if (isset($data['poste_id'])) {
        if (!filter_var($data['poste_id'], FILTER_VALIDATE_INT, ['options' => ['min_range' => 1]])) {
            $errors[] = "ID poste invalide";
        }
    }
    
    // Date de naissance : Format YYYY-MM-DD
    if (isset($data['date_naissance'])) {
        $date = DateTime::createFromFormat('Y-m-d', $data['date_naissance']);
        if (!$date || $date->format('Y-m-d') !== $data['date_naissance']) {
            $errors[] = "Date de naissance invalide (format attendu : YYYY-MM-DD)";
        }
        
        // Vérifier que la date est dans le passé et réaliste
        $now = new DateTime();
        $age = $now->diff($date)->y;
        
        if ($age < 18 || $age > 70) {
            $errors[] = "L'âge doit être entre 18 et 70 ans";
        }
    }
    
    return $errors;
}

// Utilisation
$errors = validateEmployeeData($_POST);

if (!empty($errors)) {
    foreach ($errors as $error) {
        echo "- $error\n";
    }
    exit;
}
?>
```

---

## Tests et Checklist

### 15.5.8 Checklist de Protection Mass Assignment

```bash
#!/bin/bash
# Script de vérification Mass Assignment

echo "=== Vérification Protection Mass Assignment ==="

# 1. Rechercher les assignations dynamiques dangereuses
echo "[1] Recherche d'assignations en masse non sécurisées..."
grep -rn "INSERT INTO.*implode.*\$_POST" /var/www/html/crud-rh/*.php

# Résultat attendu : Aucune correspondance (ou code commenté)

# 2. Vérifier la présence de whitelists
echo "[2] Vérification des whitelists de champs..."
grep -rn "allowed_fields\|fillable\|guarded" /var/www/html/crud-rh/*.php | wc -l

# Résultat attendu : Au moins 1 par fichier de modification

# 3. Vérifier les validations de type
echo "[3] Vérification des validations de type..."
grep -rn "filter_var\|FILTER_VALIDATE" /var/www/html/crud-rh/*.php | wc -l

# Résultat attendu : Plusieurs occurrences

# 4. Test d'injection de champ sensible
echo "[4] Test d'injection de champ 'is_admin'..."
RESPONSE=$(curl -s -X POST https://rh-interne.atlastech.local/employes/ajouter.php \
    -d "prenom=Test&nom=User&email=test@test.com&is_admin=1&salaire_mensuel=999999")

# Vérifier en BDD si is_admin=1 a été injecté
mysql -u root -p -h 192.168.30.10 -e "SELECT is_admin, salaire_mensuel FROM atlastech_rh.employes WHERE email='test@test.com';"

# Résultat attendu : is_admin=0 (ou NULL), salaire=5000.00 (valeur par défaut)

echo "=== Vérification terminée ==="
```

---

## Résumé

### 15.5.9 Règles de Protection

| Principe | Implémentation |
|----------|----------------|
| **Whitelist stricte** | Définir explicitement les champs autorisés |
| **Blacklist des champs sensibles** | Interdire is_admin, salaire_mensuel, role, etc. |
| **Validation de type** | filter_var(), regex, typage fort |
| **Permissions basées sur rôle** | Admin vs utilisateur normal |
| **Valeurs par défaut système** | Ne jamais accepter is_admin=1 de l'utilisateur |
| **Logging des tentatives** | Auditer les injections de champs suspects |

---

:::tip Prochaine Section
La section **15.6 IDOR (Insecure Direct Object Reference)** abordera la protection contre l'accès non autorisé aux ressources via manipulation d'ID.
:::